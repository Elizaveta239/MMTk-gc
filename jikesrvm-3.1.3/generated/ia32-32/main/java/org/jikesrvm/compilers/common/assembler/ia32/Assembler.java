/*
 *  This file is part of the Jikes RVM project (http://jikesrvm.org).
 *
 *  This file is licensed to You under the Eclipse Public License (EPL);
 *  You may not use this file except in compliance with the License. You
 *  may obtain a copy of the License at
 *
 *      http://www.opensource.org/licenses/eclipse-1.0.php
 *
 *  See the COPYRIGHT.txt file distributed with this work for information
 *  regarding copyright ownership.
 */
package org.jikesrvm.compilers.common.assembler.ia32;

import org.jikesrvm.*;
import org.jikesrvm.runtime.Magic;
import org.jikesrvm.compilers.baseline.ia32.BaselineCompilerImpl;
import org.jikesrvm.ia32.OutOfLineMachineCode;
import org.jikesrvm.ia32.RegisterConstants;
import org.jikesrvm.compilers.common.assembler.ForwardReference;
import org.jikesrvm.compilers.common.assembler.AbstractAssembler;
import static org.jikesrvm.ia32.RegisterConstants.GPR;

import org.vmmagic.pragma.*;
import org.vmmagic.unboxed.*;

/**
 *  <P> This class is the low-level assembler for Intel; it contains
 * functionality for encoding specific instructions into an array of
 * bytes.  It consists of three parts: </P>
 * <UL>
 *  <LI> Some support that handles common operations for generating
 *       any IA32 instruction, such as encoding the operands into the
 *       ModRM and SIB bytes
 *  <LI> Some hand-coded methods that emit instructions with
 *       distinctive formats or with special consistency requirements,
 *       such as FXCH or CMOV
 *  <LI> Machine-generated methods that emit instructions with
 *       relatively standard formats, such as binary accumulation
 *       instructions like ADD and SUB.
 * </UL>
 *  <P> This assembler provides a direct interface to the IA32 ISA: it
 * contains emit methods that generate specific IA32 opcodes, and each
 * emit method specifies the addressing modes and operand sizes that
 * it expects.  Thus, it has an emit method that generates an ADD of a
 * register-displacement operand  and an immediate operand.  It is the
 * job of the client to determine the addressing modes, operand
 * sizes and exact opcodes that it desires. </P>
 *
 *  <P> This assembler does provide support for forward branches.  It
 * is permitted to specify a branch operand as an arbitrary label, and
 * later to inform the assembler to which instruction this label
 * refers.  The assembler, when informed to what the label refers,
 * will go back and generate the appropriate offsets for all branches
 * that refer to the given label. The mechanism is implemented by the
 * following methods and helper classes:
 * <UL>
 * <LI> {@link #forwardRefs}
 * <LI> {@link #resolveForwardReferences}
 * <LI> {@link #patchUnconditionalBranch}
 * <LI> {@link #patchConditionalBranch}
 * <LI> {@link #emitJCC_Cond_Label}
 * <LI> {@link #emitJMP_Label}
 * <LI> {@link #emitCALL_Label}
 * <LI> {@link ForwardReference}
 * </UL>
 * </P>
 *
 *  <P> There is also support for generating tableswitches.  This
 * consists providing support for storing tables of relative addresses
 * that can be used to compute the target of a tableswitch.  This
 * support assumes a particular code sequence for tableswitches
 * (followed by baseline and optimizing compilers).  See {@link
 * #emitOFFSET_Imm_ImmOrLabel} for details. </P>
 *
 *  <P> The automatically-generated emit methods of this assembler
 * exploit regularities in the IA32 binary encoding; for example,
 * several instructions (ADD, ADC, SUB, AND, OR, XOR) can be
 * classified as binary accumulators that share a common set of
 * permitted addressing modes and binary encoding all the way down a
 * special case for enconding operands EAX and an immediate.  A shell
 * script (genAssembler.sh in the intel assembler source directory)
 * explots this by specifying a generic way of emtting a binary
 * accumulation and then calling it for each specific opcode that fits
 * that format.  These generated methods are combined with the
 * hand-coded ones (from Assembler.in, also in the assembler
 * source directory) as part of the Jikes RVM build process. </P>
 *
 *  <P> This assembler is shared by the baseline and optimizing
 * compilers: it used directly by the baseline compiler, while the
 * optimizing compiler has an {@link org.jikesrvm.ArchitectureSpecificOpt.AssemblerOpt}
 * that is built on top of this one to match
 * {@link org.jikesrvm.compilers.opt.ir.Instruction}s and
 * {@link org.jikesrvm.compilers.opt.ir.Operator}s to the emit methods
 * this assembler provides.  The {@link org.jikesrvm.ArchitectureSpecificOpt.AssemblerOpt}
 * is entirely machine-generated, and this
 * requires that the methods for encoding instructions use a stylized
 * naming and signiture convention that is designed to make the method
 * signiture computable from the opcode and the operand types.  The
 * naming convention is as follows:
 *
 * <PRE>
 *   final void emit<EM>opcode</EM>\(_<EM>operand code</EM>\)*[_<EM>size</EM>](\(<EM>operand arguments</EM>\)*)
 * </PRE>
 *
 * where the following substitutions are made:
 * <DL>
 * <DT> <EM>opcode</EM>
 * <DI> is the opcode of the instruction (e.g. ADC, MOV, etc)
 *
 * <DT> <EM>operand code</EM>
 * <DI> represents the type of the nth operand:
 *   <DL>
 *   <DT> "Imm"     <DI> immediate operands
 *   <DT> "Reg"     <DI> register operands
 *   <DT> "RegInd"  <DI> register indirect operands
 *   <DT> "RegDisp" <DI> register displacement
 *   <DT> "RegOff"  <DI> shifted index + displacement
 *   <DT> "RegIdx"  <DI> register base + shifted index + displacement
 *   <DT> "Cond"    <DI> condition codes
 *   </DL>
 *
 * <DT> <EM>size</EM>
 * <DI> indicates non-word-sized operations
 *   <DL>
 *   <DT> "Byte"    <DI> bytes
 *   <DT> "Word"    <DI> Intel "words" (i.e. 16 bites)
 *   <DT> "Quad"    <DI> quad words (i.e. double-precision floating point)
 *   </DL>
 *
 * <DT> <EM>operand arguments</EM>
 * <DI> are the needed components of the operands, in order
 *  <DL>
 *  <DT> "Imm"
 *  <DI>
 *    <UL>
 *     <LI> immediate value (int)
 *    </UL>
 *  <DT> "Reg"
 *  <DI>
 *    <UL>
 *     <LI> register number (byte)
 *    </UL>
 *  <DT> "RegInd"
 *  <DI>
 *    <UL>
 *     <LI> register number (byte)
 *    </UL>
 *  <DT> "RegDisp"
 *  <DI>
 *    <UL>
 *     <LI> register number (byte)
 *     <LI> displacement (int)
 *    </UL>
 *  <DT> "RegOff"
 *  <DI>
 *    <UL>
 *     <LI> index register (byte)
 *     <LI> scale (short)
 *     <LI> displacement (int)
 *    </UL>
 *  <DT> "RegIdx"
 *  <DI>
 *    <UL>
 *     <LI> base register (byte)
 *     <LI> index register (byte)
 *     <LI> scale (short)
 *     <LI> displacement (int)
 *    </UL>
 *  <DT> "Cond"
 *  <DI>
 *    <UL>
 *     <LI> condition code mask (byte)
 *    </UL>
 *  </DL>
 * </DL>
 *
 * @see org.jikesrvm.ArchitectureSpecificOpt.AssemblerOpt
 * @see Lister
 * @see ForwardReference
 *
*/
public abstract class Assembler extends AbstractAssembler implements RegisterConstants, AssemblerConstants {

  /**
   * The lister object is used to print generated machine code.
   */
  protected final Lister lister;

  /**
   * The array holding the generated binary code.
   */
  private byte [] machineCodes;

  /**
   * The current end of the generated machine code
   */
  protected int mi;

  /**
   * Create an assembler with a given machine code buffer size that
   * will not print the machine code as it generates it.
   * The buffer size is merely a heuristic, because the assembler will
   * expand its buffer if it becomes full.
   *
   * @param bytecodeSize initial machine code buffer size.
   */
  protected Assembler (int bytecodeSize) {
    this(bytecodeSize, false);
  }

  /**
   * Create an assembler with a given machine code buffer size and
   * tell it whether or not to print machine code as it generates it.
   * The buffer size is merely a heuristic, because the assembler will
   * expand its buffer if it becomes full.
   *
   * @param bytecodeSize initial machine code buffer size.
   * @param shouldPrint whether to dump generated machine code.
   */
  protected Assembler (int bytecodeSize, boolean shouldPrint) {
    machineCodes = new byte[bytecodeSize*CODE_EXPANSION_FACTOR + CODE_OVERHEAD_TERM];
    lister = shouldPrint ? new Lister((ArchitectureSpecific.Assembler) this) : null;
  }

  /**
   * Create an assembler with a given machine code buffer size and
   * tell it whether or not to print machine code as it generates it.
   * The buffer size is merely a heuristic, because the assembler will
   * expand its buffer if it becomes full.
   *
   * @param bytecodeSize initial machine code buffer size.
   * @param shouldPrint whether to dump generated machine code.
   * @param comp BaselineCompilerImpl instance that this assembler is associated with;
   *           currently ignored on IA32.
   */
  protected Assembler (int bytecodeSize, boolean shouldPrint, BaselineCompilerImpl comp) {
    this(bytecodeSize, shouldPrint);
  }

  /**
   * Heuristic constant used to calculate initial size of the machine
   * code buffer.  This is an average of how many bytes of generated
   * code come from a given bytecode in the baseline compiler.
   */
  private static final int CODE_EXPANSION_FACTOR =  12;

  /**
   * Heuristic constant used to calculate initial size of the machine
   * code buffer.  This is an estimate of the fixed method overhead
   * code generated by the baseline compiler, such as method
   * prologue.
   */
  private static final int CODE_OVERHEAD_TERM    = 100;

  /**
   * Return the current offset in the generated code buffer of the
   * end of the genertaed machine code.
   *
   * @return the end of the generated machine code.
   */
  public final int getMachineCodeIndex () {
    return mi;
  }

  /**
   * Set the given byte offset in the machine code array to the
   * given byte value.  This is the low-level function by which the
   * assembler produces binary code into its machine code buffer.
   * This function will resize the underlying machine code array if
   * the index given exceeds the array's length.
   *
   * @param index the byte offset into which to write
   * @param data the byte data value to write
   */
  @NoNullCheck
  @NoBoundsCheck
  protected final void setMachineCodes(int index, byte data) {
    if(index < machineCodes.length) {
      machineCodes[index] = data;
    } else {
      growMachineCodes(index, data);
    }
  }

  @NoInline
  private void growMachineCodes(int index, byte data) {
    byte [] old = machineCodes;
    machineCodes = new byte [2 * old.length ];
    System.arraycopy(old, 0, machineCodes, 0, old.length);
    machineCodes[index] = data;
  }


  /**
   * Create a MachineCode object
   */
  public final ArchitectureSpecific.MachineCode finalizeMachineCode(int[] bytecodeMap) {
    return new ArchitectureSpecific.MachineCode(getMachineCodes(), bytecodeMap);
  }

  /**
   * Should code created by this assembler instance be allocated in the
   * hot code code space? By default the answer is false (ie, no).
   */
  protected boolean isHotCode() { return false; }

  /**
   * Return a copy of the generated code as a CodeArray.
   * @return a copy of the generated code as a CodeArray.
   */
  public final ArchitectureSpecific.CodeArray getMachineCodes () {
    int len = getMachineCodeIndex();
    ArchitectureSpecific.CodeArray trimmed = ArchitectureSpecific.CodeArray.Factory.create(len, isHotCode());
    for (int i=0; i<len; i++) {
      trimmed.set(i, machineCodes[i]);
    }
    return trimmed;
  }

  /**
   * Give the lister a message associated with a particular
   * bytecode.  This is used by the baseline assembler to print the
   * bytecode associated with portions of machine code.  (The
   * optimizing compiler does not do this because its association
   * between bytecodes and generated code is much less direct).
   *
   * @param bytecodeNumber the offset of the current bytecode in the
   *     current method's bytecode array.
   * @param bc a message descriptive of the current bytecode.
   */
  public final void noteBytecode (int bytecodeNumber, String bc) {
    if (lister != null) lister.noteBytecode(bytecodeNumber, bc);
  }

  @NoInline
  public final void noteBytecode (int i, String bcode, int x) {
    noteBytecode(i, bcode+" "+x);
  }

  @NoInline
  public final void noteBytecode (int i, String bcode, long x) {
    noteBytecode(i, bcode+" "+x);
  }

  @NoInline
  public final void noteBytecode (int i, String bcode, Object o) {
    noteBytecode(i, bcode+" "+o);
  }

  @NoInline
  public final void noteBytecode (int i, String bcode, int x, int y) {
    noteBytecode(i, bcode+" "+x+" "+y);
  }

  @NoInline
  public final void noteBranchBytecode (int i, String bcode, int off,
               int bt) {
    noteBytecode(i, bcode +" "+off+" ["+bt+"] ");
  }

  @NoInline
  public final void noteTableswitchBytecode (int i, int l, int h, int d) {
    noteBytecode(i, "tableswitch [" + l + "--" + h + "] " + d);
  }

  @NoInline
  public final void noteLookupswitchBytecode (int i, int n, int d) {
    noteBytecode(i, "lookupswitch [<" + n + ">]" + d);
  }

  /**
   * Inform the lister of a comment related to the currently
   * generated machine code.
   *
   * @param comment a comment string
   */
  public final void comment (String comment) {
    if (lister != null) lister.comment(mi, comment);
  }

  /**
   * Print the raw bits of the current instruction.  It takes the
   * start of the instruction as a parameter, and prints from that
   * start to the current machine code index.
   *
   * @see #getMachineCodeIndex
   *
   * @param start the starting index of the last instruction.
   */
  public final void writeLastInstruction(int start) {
    for (int j=start; j<mi; j++) {
      if (j < machineCodes.length) {
        VM.sysWrite(Lister.hex(machineCodes[j]));
      } else {
        VM.sysWrite(Lister.hex((byte)0x0));
      }
    }
  }

  /**
   * Find out whether a given signed value can be represented in a
   * given number of bits.
   *
   * @param val the value to be represented
   * @param bits the number of bits to use.
   * @return true if val can be encoded in bits.
   */
  @Inline
  protected static boolean fits (Offset val, int bits) {
    return fits(val.toWord(), bits);
  }

  /**
   * Find out whether a given signed value can be represented in a
   * given number of bits.
   *
   * @param val the value to be represented
   * @param bits the number of bits to use.
   * @return true if val can be encoded in bits.
   */
  @Inline
  protected static boolean fits (Address val, int bits) {
    return fits(val.toWord(), bits);
  }

  /**
   * Find out whether a given signed value can be represented in a
   * given number of bits.
   *
   * @param val the value to be represented
   * @param bits the number of bits to use.
   * @return true if val can be encoded in bits.
   */
  @Inline
  protected static boolean fits (Word val, int bits) {
    Word o = val.rsha(bits-1);
    return (o.isZero() || o.isMax());
  }

  /**
   * Find out whether a given signed value can be represented in a
   * given number of bits.
   *
   * @param val the value to be represented
   * @param bits the number of bits to use.
   * @return true if val can be encoded in bits.
   */
  @Inline
  protected static boolean fits (int val, int bits) {
    val = val >> bits-1;
    return (val == 0 || val == -1);
  }

  /**
   * In the representation of addressing modes in the ModRM and SIB
   * bytes, the code for register-displacement for on ESP has a
   * special meaning.  Thus, when register-displacement mode using ESP
   * is desired, this special SIB (scale-index-base) byte must be
   * emitted.
   */
  private static final byte SIBforESP = (byte) ((0<<6) + (4<<3) + ESP.value()); // (scale factor 1) no index, ESP is base

  /**
   * Generate a REX prefix if necessary
   *
   * @param W is a quad word override needed
   * @param R_reg extension of the modrm field
   * @param X_reg extension of the SIB index field
   * @param B_reg extension of the modrm field, SIB base or opcode reg field
   */
  @Inline
  private void generateREXprefix(boolean W, MachineRegister R_reg, MachineRegister X_reg, MachineRegister B_reg) {
    boolean R = R_reg != null && R_reg.needsREXprefix();
    boolean X = X_reg != null && X_reg.needsREXprefix();
    boolean B = B_reg != null && B_reg.needsREXprefix();
    if (W || R || X || B) {
      if (VM.VerifyAssertions) VM._assert(!VM.buildFor32Addr());
      byte prefixByte = (byte)(0x40 | (W ? 8 : 0) | (R ? 4 : 0) | (X ? 2 : 0) | (B ? 1 : 0));
      setMachineCodes(mi++, prefixByte);
    }
  }

  /**
   * Return a ModRM byte encoding a source and destination register
   * (i.e. for a register-register instruction).
   *
   * @param reg1 the r/m register.
   * @param reg2 the other register or extended opcode.
   * @return the encoded ModRM byte.
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  private byte regRegModRM(MachineRegister reg1, MachineRegister reg2) {
    return (byte) ((3 << 6) | ((reg2.value() & 7) << 3) | (reg1.value() & 0x7));
  }

  /**
   * Return a ModRM byte encoding a source register-32-bit-displacement
   * operand and a destination register.  Note that the displacement
   * is handled separately, and not encoded in the ModRM itself.
   *
   * @param reg1 the r/m register.
   * @param reg2 the other register or extended opcode.
   * @return the encoded ModRM byte.
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  private byte regDisp32RegModRM(MachineRegister reg1, MachineRegister reg2) {
    return (byte) ((2 << 6) | ((reg2.value() & 7)<< 3) | (reg1.value() & 7));
  }

  /**
   * Return a ModRM byte encoding a source register-8-bit-displacement
   * operand and a destination register.  Note that the displacement
   * is handled separately, and not encoded in the ModRM itself.
   *
   * @param reg1 the r/m register.
   * @param reg2 the other register or extended opcode.
   * @return the encoded ModRM byte.
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  private byte regDisp8RegModRM(MachineRegister reg1, MachineRegister reg2) {
    return (byte) ((1 << 6) | ((reg2.value() & 7) << 3) | (reg1.value() & 7));
  }

  /**
   * Return a ModRM byte encoding a source register-indirect
   * operand and a destination register.
   *
   * @param reg1 the r/m register.
   * @param reg2 the other register or extended opcode.
   * @return the encoded ModRM byte.
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  private byte regIndirectRegModRM(MachineRegister reg1, MachineRegister reg2) {
    return (byte) (((reg2.value() & 7) << 3) | (reg1.value() & 7));
  }

  /**
   * The more complex IA32 addressing modes require a
   * scale-index-base (SIB) byte.  This is used to encode addressing
   * modes such as [ indexReg \<\< scale + baseReg ].  This method
   * encodes the SIB byte for a given base, index and scale.
   *
   * @param scale the shift amount for the index register value.
   * @param baseReg the base register.
   * @param indexReg the index register.
   * @return the encoded SIB byte.
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  private byte sib(short scale, MachineRegister baseReg, MachineRegister indexReg) {
    return (byte) ((scale << 6) | ((indexReg.value() & 7) << 3) | (baseReg.value() & 7));
  }

  /**
   * Generate the appropriate bytes into the generated machine code
   * to represent a register-register instruction.
   *
   * @param reg1 the r/m operand.
   * @param reg2 the other register or extended opcode.
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  private void emitRegRegOperands(MachineRegister reg1, MachineRegister reg2) {
    setMachineCodes(mi++, regRegModRM(reg1, reg2));
  }

  /**
   * Generate the appropriate bytes into the generated machine code
   * to represent a register-32-bit-displacement--register
   * instruction. This method generates the appropriate ModRM, the SIB
   * if needed for the ESP special case, and the little-endian encoded
   * 32 bit displacement.
   *
   * @see #SIBforESP
   *
   * @param reg1 the r/m operand.
   * @param disp the 32 bit displacement.
   * @param reg2 the other register or extended opcode.
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  private void emitRegDisp32RegOperands(MachineRegister reg1, int disp, MachineRegister reg2) {
    setMachineCodes(mi++, regDisp32RegModRM(reg1, reg2));
    if (reg1 == ESP) setMachineCodes(mi++, SIBforESP);
    emitImm32(disp);
  }

  /**
   * Generate the appropriate bytes into the generated machine code
   * to represent a register-8-bit-displacement--register
   * instruction. This method generates the appropriate ModRM, the SIB
   * if needed for the ESP special case, and the little-endian encoded
   * 32 bit displacement.
   *
   * @see #SIBforESP
   *
   * @param reg1 the r/m operand.
   * @param disp the 8 bit displacement.
   * @param reg2 the other register or extended opcode.
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  private void emitRegDisp8RegOperands(MachineRegister reg1, byte disp, MachineRegister reg2) {
    setMachineCodes(mi++, regDisp8RegModRM(reg1, reg2));
    if (reg1 == ESP) setMachineCodes(mi++, SIBforESP);
    emitImm8(disp);
  }

  /**
   * Generate the appropriate bytes into the generated machine code
   * to represent a register-displacement--register instruction.  This
   * method simply chooses the appropriate lower-level method based on
   * displacement size
   *
   * @see #emitRegDisp32RegOperands
   * @see #emitRegDisp8RegOperands
   *
   * @param reg1 the r/m operand.
   * @param disp the displacement.
   * @param reg2 the other register or extended opcode.
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  private void emitRegDispRegOperands(MachineRegister reg1, Offset disp, MachineRegister reg2) {
    if (reg1 == GPR.EIP) {
      setMachineCodes(mi++, regIndirectRegModRM(EBP, reg2)); // EBP == RIP addressing mode
      emitImm32(disp);
    } else if (fits(disp,8)) {
      emitRegDisp8RegOperands(reg1, (byte)disp.toInt(), reg2);
    } else {
      if (VM.VerifyAssertions) VM._assert(fits(disp,32));
      emitRegDisp32RegOperands(reg1, disp.toInt(), reg2);
    }
  }

  /**
   * Generate the appropriate bytes into the generated machine code
   * to express a register-indirect--register instruction.  This
   * method handles low-level encoding issues, specifically the
   * special cases for register indirect mode on ESP and EBP.  Using
   * ESP requires an SIB byte, and EBP cannot be used in indirect mode
   * at all (that encoding is used to express scaled-index-displacement
   * mode) so this method uses register-displacement with a 0
   * displacement to fake it.
   *
   * @see #emitRegDispRegOperands
   *
   * @param reg1 the r/m operand
   * @param reg2 the other register or extended opcode
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  private void emitRegIndirectRegOperands(MachineRegister reg1, MachineRegister reg2) {
    if (reg1 == EBP) {
      emitRegDispRegOperands(reg1, Offset.zero(), reg2);
    } else {
      setMachineCodes(mi++, regIndirectRegModRM(reg1, reg2));
      if (reg1 == ESP) setMachineCodes(mi++, SIBforESP);
    }
  }

  /**
   * Generate the appropriate bytes into the generated code to denote
   * a scaled-register+displacement--register instruction.  This
   * expresses the case where the SIB byte is used, but no base
   * register is desired.  This method handles the somewhat convoluted
   * special case used to express this mode (the r/m register is 4/ESP and
   * the base register must be 5/EBP).
   *
   * @param index the index register for the r/m operand
   * @param scale the amount to shift the index register
   * @param disp the displacement for the r/m operand
   * @param reg2 the other operand or the extended opcode
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  private void emitRegOffRegOperands(MachineRegister index, short scale, Offset disp, MachineRegister reg2) {
    setMachineCodes(mi++, regIndirectRegModRM(ESP, reg2));
    setMachineCodes(mi++, sib(scale, EBP, index));
    emitImm32(disp);
  }

  /**
   * Generate the appropriate bytes into the generated code to denote
   * an absolute-address--register instruction.
   *
   * @param disp the displacement for the r/m operand
   * @param reg2 the other operand or the extended opcode
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  private void emitAbsRegOperands(Address disp, MachineRegister reg2) {
    if (VM.buildFor32Addr()) {
      setMachineCodes(mi++, regIndirectRegModRM(EBP, reg2)); // EBP == No displacement
    } else {
      setMachineCodes(mi++, regIndirectRegModRM(ESP, reg2)); // ESP == SIB byte
      setMachineCodes(mi++, sib((short)0, EBP, ESP)); // EBP+ESP<<0 == no SIB
    }
    emitImm32(disp);
  }

  /**
   * Generate the full glory of scaled-index-base-displacement
   * addressing to the generated machine code.  This method handles
   * various special cases, mostly choosing the smallest displacement
   * possible.
   *
   * @param base the base register for the r/m operand
   * @param index the index register for the r/m operand
   * @param scale the amount to shift the index register
   * @param disp the displacement for the r/m operand
   * @param reg2 the other operand or the extended opcode
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  private void emitSIBRegOperands(MachineRegister base, MachineRegister index, short scale, Offset disp, MachineRegister reg2) {
    if (VM.VerifyAssertions) VM._assert(index != ESP);
    if (disp.EQ(Offset.zero()) && base != EBP) {
      setMachineCodes(mi++, regIndirectRegModRM(ESP, reg2));
      setMachineCodes(mi++, sib(scale, base, index));
    } else if (fits(disp,8)) {
      setMachineCodes(mi++, regDisp8RegModRM(ESP, reg2));
      setMachineCodes(mi++, sib(scale, base, index));
      emitImm8((byte)disp.toInt());
    } else {
      setMachineCodes(mi++, regDisp32RegModRM(ESP, reg2));
      setMachineCodes(mi++, sib(scale, base, index));
      emitImm32(disp);
    }
  }

  /**
   * Generate the smallest-byte-first IA32 encoding of 32 bit
   * immediates into the generated code.
   *
   * @param disp the displacement to generate.
   */
  @Inline
  private void emitImm32(Offset disp) {
    emitImm32(disp.toWord());
  }

  /**
   * Generate the smallest-byte-first IA32 encoding of 32 bit
   * immediates into the generated code.
   *
   * @param disp the displacement to generate.
   */
  @Inline
  private void emitImm32(Address disp) {
    emitImm32(disp.toWord());
  }

  /**
   * Generate the smallest-byte-first IA32 encoding of 32 bit
   * immediates into the generated code.
   *
   * @param disp the displacement to generate.
   */
  @Inline
  private void emitImm32(Word disp) {
    if (VM.VerifyAssertions) VM._assert(fits(disp,32));
    mi = emitImm32(disp.toInt(), mi);
  }

  /**
   * Generate the smallest-byte-first IA32 encoding of 32 bit
   * immediates into the generated code.
   *
   * @param imm the immediate to generate.
   */
  @Inline
  private void emitImm32(int imm) {
    mi = emitImm32(imm, mi);
  }

  /**
   * Generate the smallest-byte first x86_64 encoding of the 64 bit
   * immeditate into the generated code.
   *
   * @param imm the immediate the generate;
   */
  @Inline
  private void emitImm64(long imm) {
    mi = emitImm64(imm, mi);
  }

  /**
   * Generate the IA32 encoding of an 16 bit immediate into the
   * generated code.
   *
   * @param imm the immediate to generate.
   */
  @Inline
  private void emitImm16(int imm) {
    mi = emitImm16(imm, mi);
  }

  /**
   * Generate the IA32 encoding of an 8 bit immediate into the
   * generated code.
   *
   * @param imm the immediate to generate.
   */
  @Inline
  private void emitImm8(int imm) {
    mi = emitImm8(imm, mi);
  }

  /**
   * Generate the smallest-byte-first IA32 encoding of 16 bit
   * immediates into the generated code at the location specified.
   *
   * @param imm the immediate to generate.
   * @param idx the location in the generated code to write.
   */
  @Inline
  private int emitImm16(int imm, int idx) {
    setMachineCodes(idx++, (byte) ((imm >>  0) & 0xFF));
    setMachineCodes(idx++, (byte) ((imm >>  8) & 0xFF));
    return idx;
  }

  /**
   * Generate the smallest-byte-first IA32 encoding of 32 bit
   * immediate into the generated code at the location specified.
   *
   * @param imm the immediate to generate.
   * @param idx the location in the generated code to write.
   */
  @Inline
  private int emitImm32(int imm, int idx) {
    setMachineCodes(idx++, (byte) ((imm >>  0) & 0xFF));
    setMachineCodes(idx++, (byte) ((imm >>  8) & 0xFF));
    setMachineCodes(idx++, (byte) ((imm >> 16) & 0xFF));
    setMachineCodes(idx++, (byte) ((imm >> 24) & 0xFF));
    return idx;
  }

  /**
   * Generate the smallest-byte first x86_64 encoding of the 64 bit
   * immeditate into the generated code at the location specified.
   *
   * @param imm the immediate the generate;
   * @param idx the location in the generated code to write.
   */
  private int emitImm64(long imm, int idx) {
      setMachineCodes(idx++, (byte) ((imm >>  0) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >>  8) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >>  16) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >>  24) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >>  32) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >>  40) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >>  48) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >>  56) & 0xFF));
      return idx;
  }

  /**
   * Generate the IA32 encoding of an 8 bit immediate into the
   * generated code at the location specified.
   *
   * @param imm the immediate to generate.
   * @param idx the location in the generated code to write.
   */
  @Inline
  private int emitImm8(int imm, int idx) {
    setMachineCodes(idx++, (byte) imm);
    return idx;
  }

  /**
   * Generate a conditional opcode given the base opcode and the
   * condition code desired.  The CMOVcc, SETcc and Jcc families of
   * instructions all have opcodes defined as a base opcode plus some
   * bits representing the condition code.  (of course, FCMOV does not
   * this, since that would be too logical).
   *
   * @param opCode the base opcode to emit
   * @param cond the condition code desired
   */
  @Inline
  private void emitCondOpByte(byte opCode, byte cond) {
    setMachineCodes(mi++, (byte) (opCode | cond));
  }

  /**
   * Generate a locking prefix word into the generated code.  Locking
   * operations on IA32 are expressed by writing a locking byte before
   * the instruction.
   */
  @Inline
  public final void emitLockNextInstruction() {
    setMachineCodes(mi++, (byte) 0xF0);
    if (lister != null) lister.lockPrefix();
  }

  /**
   * Generate a branch likely prefix into the generated code.
   */
  @Inline
  public final void emitBranchLikelyNextInstruction() {
    setMachineCodes(mi++, (byte) 0x3E);
    if (lister != null) lister.branchLikelyPrefix();
  }

  /**
   * Generate a branch unlikely prefix into the generated code.
   */
  @Inline
  public final void emitBranchUnlikelyNextInstruction() {
    setMachineCodes(mi++, (byte) 0x2E);
    if (lister != null) lister.branchUnlikelyPrefix();
  }

  /**
   * Generate a patch point into the generated code.
   * (1) force patch point to be 32 bit aligned by optionally
   *   generating a nop.
   * (2) emit a short branch (2 byte) around 3 bytes of nop.
   * (3) If the the code is later patched, we first patch the 3
   *   nop bytes to be the upper 24 bits of a long jump
   *   instruction, then update the 2 bytes of the patch
   *   point to be an unconditional jump with a 32 bit immediate.
   */
  @Inline
  public final void emitPatchPoint() {
    emitNOP((4-mi-1) & 3);
    ForwardReference r = forwardJMP();
    emitNOP(3);
    r.resolve(this);
  }

  /**
   * Apply a patch.
   * We expect the following instruction stream:
   *  i1; JMP rel8; NOP; NOP; NOP; i2;
   * where patchOffset is the index of the last NOP.
   * We patch it to be
   *  i1; JMP rel32; i2;
   *
   * @param code    the code array to patch
   * @param patchOffset the offset of the last byte of the patch point
   * @param rel32     the new immediate to use in the branch instruction
   *          the code patcher is going to lay down before patchOffset
   */
  public static void patchCode(ArchitectureSpecific.CodeArray code, int patchOffset, int rel32) {
    byte p0 = (byte)0xE9;
    byte p1 = (byte) (rel32 & 0x000000ff);
    byte p2 = (byte)((rel32 & 0x0000ff00) >>>  8);
    byte p3 = (byte)((rel32 & 0x00ff0000) >>> 16);
    byte p4 = (byte)((rel32 & 0xff000000) >>> 24);
    if ((patchOffset & 0x2) == 0x2) {
      // (a) lay down p4,p3,p2 one byte at a time
      // (b) pick up the two bytes before p0 and then
      //   lay down b2b1p0p1 as a word.
      code.set(patchOffset--, p4);
      code.set(patchOffset--, p3);
      code.set(patchOffset--, p2);
      patchOffset -= 2; // skip over p1, p0
      byte b1 = code.get(patchOffset--);
      byte b2 = code.get(patchOffset);
      int patch = (((int)p1&0xff) << 24) | (((int)p0&0xff) << 16) |
                  (((int)b1&0xff) << 8)  |  ((int)b2&0xff);
      Magic.setIntAtOffset(code, Offset.fromIntSignExtend(patchOffset), patch);
    } else {
      // (a) lay down p4
      // (b) lay down p0p1p2p3 as a word
      code.set(patchOffset--, p4);
      patchOffset -= 3; // skip over p0p1p2p3
      int patch = (((int)p3&0xff) << 24) | (((int)p2&0xff) << 16) |
                  (((int)p1&0xff) << 8)  |  ((int)p0&0xff);
      Magic.setIntAtOffset(code, Offset.fromIntSignExtend(patchOffset), patch);
    }
  }

  /**
   * Return the appropriate condition code if we want to
   * reverse the sense of the branch
   */
  public final byte flipCode(byte cond) {
    switch (cond) {
      case EQ: return NE;
      case NE: return EQ;
      case LT: return GE;
      case GT: return LE;
      case LE: return GT;
      case GE: return LT;
      default: throw new InternalError("Unexpected condition code");
    }
  }

  /**
   * Generate a forward JMP instruction into the generated code.
   * This form is used when the compiler wants to hang onto the
   * forward reference object and call resolve on it directly.  These
   * forward references are not handled by the mechanism in the
   * assembler; the client is responsible for calling resolve on the
   * reference when generating the target instruction.  The baseline
   * compiler uses this form for jumps within the machine code for a
   * single bytecode.
   */
  public final ForwardReference forwardJMP () {
    int miStart = mi;
    ForwardReference r =  new ForwardReference.ShortBranch(mi);
    setMachineCodes(mi++, (byte) 0xEB);
    mi += 1; // leave space for displacement
    if (lister != null) lister.I(miStart, "JMP", 0);
    return r;
  }

  /**
   * Generate a forward Jcc instruction into the generated code.
   * This form is used when the compiler wants to hang onto the
   * forward reference object and call resolve on it directly.  These
   * forward references are not handled by the mechanism in the
   * assembler; the client is responsible for calling resolve on the
   * reference when generating the target instruction.  The baseline
   * compiler uses this form for jumps within the machine code for a
   * single bytecode.
   *
   * @param cond the condition code on which to branch
   */
  public final ForwardReference forwardJcc (byte cond) {
    int miStart = mi;
    ForwardReference r =  new ForwardReference.ShortBranch(mi);
    setMachineCodes(mi++, (byte) (0x70 + cond));
    mi += 1; // leave space for displacement
    if (lister != null) lister.I(miStart, "J" + CONDITION[cond], 0);
    return r;
  }

  /**
   * The set of outstanding forward references.  This list is used by
   * the assembler to keep track of all outstanding forward
   * references.  References are put on this list by the emit methods
   * for JMP and Jcc when they find a branch that is going forward.
   * Each reference must understand what instruction it is looking for
   * and how to patch its source instruction.  Then, when the client
   * calls resolveForwardBranches, the assembler searches this list to
   * find branches that match the instruction currently being
   * generated, and calls the resolve method on each one that does.
   *
   * All forward branches have a label as the branch target; clients
   * can arbirarily associate labels and instructions, but must be
   * consistent in giving the chosen label as the target of branches
   * to an instruction and calling resolveForwardBranches with the
   * given label immediately before emitting the target instruction.
   * See the header comments of ForwardReference for more details.
   */
  protected ForwardReference forwardRefs;

  /**
   * Resolve all forward branches that have the given target, and
   * make them branch to the instruction currently being generated.
   * Clients of the assembler call this method immediately before they
   * emit the instruction intended to be the target of the given
   * label.
   *
   * All forward branches have a label as the branch target; clients
   * can arbirarily associate labels and instructions, but must be
   * consistent in giving the chosen label as the target of branches
   * to an instruction and calling resolveForwardBranches with the
   * given label immediately before emitting the target instruction.
   * See the header comments of ForwardReference for more details.
   *
   * @param label the forward branch label to resolve
   */
  public final void resolveForwardReferences (int label) {
    if (forwardRefs == null) return; // premature optimization
    forwardRefs = ForwardReference.resolveMatching(this, forwardRefs, label);
  }

  /**
   * Set up a code sequence to push a return address. This involves pushing the
   * current instruction address, and setting up an ADD that gets resolved later.
   *
   * @param bReturn the return address that is to be loaded.
   */
  public final void generateLoadReturnAddress(int bReturn) {
    /* Push the IP */
    emitCALL_Imm(mi + 5);
    ForwardReference r = new ForwardReference.LoadReturnAddress(mi, bReturn);
    forwardRefs = ForwardReference.enqueue(forwardRefs, r);
    /* Fake MAX_INTEGER to ensure 32 bit immediate */
    emitADD_RegInd_Imm(ESP, Integer.MAX_VALUE);
  }

  /**
   * Patch the code sequence at sourceIndex to load the complete instruction address
   * of the current instruction.
   *
   * @param sourceIndex the machine code offset of the load return addres to patch.
   */
  @Override
  public final void patchLoadReturnAddress(int sourceIndex) {
    /* We have the following pattern:
     * | PUSH EIP | [SP] += | IMM32 |
     *            ^         ^
     *  sourceIndex        +3 */
    int ipDelta = mi - sourceIndex;
    emitImm32(ipDelta, sourceIndex + 3);
  }

  /**
   * Generate a code sequence that will place the address of the start of the
   * method in destReg
   *
   * @param destReg register to hold address of start of method
   */
  public final void emitMETHODSTART_Reg(GPR destReg) {
    if (VM.buildFor32Addr()) {
      Offset pcThunkOffset;
      pcThunkOffset = OutOfLineMachineCode.pcThunkInstructionsField[destReg.value()].getOffset();
      emitCALL_Abs(Magic.getTocPointer().plus(pcThunkOffset));
      emitADD_Reg_Imm(destReg, -mi);
    } else {
      emitLEA_Reg_RegDisp_Quad(destReg, GPR.EIP, Offset.fromIntZeroExtend(Integer.MAX_VALUE));
      emitImm32(-mi, mi-4);
    }
  }

  /**
   * Make a forward reference and emit a long JMP
   * @param btarget optional
   * @return a forward reference for patching later
   */
  public final ForwardReference generatePendingJMP(int btarget) {
    int miStart = mi;
    ForwardReference r = new ForwardReference.UnconditionalBranch(mi, btarget);
    setMachineCodes(mi++, (byte) 0xE9);
    mi += 4; // leave space for displacement
    if (lister != null) lister.I(miStart, "JMP", 0);
    return r;
  }
  // END OSR SUPPORT //

  /**
   * Make the given unconditional branch branch to the current
   * generated instruction.  It is the client's responsibility to
   * ensure the given source index really does contain an
   * unconditional branch.
   *
   * @param sourceIndex the machine code offset of the unconditional
   *          branch to patch.
   */
  @Override
  public final void patchUnconditionalBranch (int sourceIndex) {
    if (VM.AlignmentChecking || isHotCode()) {
      // force 4byte alignment here
      emitNOP((4 - mi) & 3);
    }
    if (lister != null) lister.comefrom(mi, sourceIndex);
    int relOffset = mi - (sourceIndex+5);
    sourceIndex++; // skip the op code
    emitImm32(relOffset, sourceIndex);
  }

  /**
   * Make the given conditional branch branch to the current
   * generated instruction.  It is the client's responsibility to
   * ensure the given source index really does contain an
   * conditional branch.
   *
   * @param sourceIndex the machine code offset of the conditional
   *          branch to patch.
   */
  @Override
  public final void patchConditionalBranch (int sourceIndex) {
    if (VM.AlignmentChecking || isHotCode()) {
      // force 4byte alignment here
      emitNOP((4 - mi) & 3);
    }
    if (lister != null) lister.comefrom(mi, sourceIndex);
    int relOffset = mi - (sourceIndex+6);
    sourceIndex += 2; // skip the (two byte) op code
    emitImm32(relOffset, sourceIndex);
  }

  /**
   * Make the given unconditional branch branch to the current
   * generated instruction.  It is the client's responsibility to
   * ensure the given source index really does contain an
   * unconditional branch.  This instruction requires that the branch
   * have been generated with an 8 bit offset.
   *
   * @param sourceIndex the machine code offset of the unconditional
   *          branch to patch.
   */
  public final void patchShortBranch (int sourceIndex) {
    if (VM.AlignmentChecking || isHotCode()) {
      // force 4byte alignment here
      emitNOP((4 - mi) & 3);
    }
    if (lister != null) lister.comefrom(mi, sourceIndex);
    int relOffset = mi - (sourceIndex+2);
    if (VM.VerifyAssertions) VM._assert(fits(relOffset, 8), "offset too large: "+relOffset);
    sourceIndex++; // skip the op code
    emitImm8((byte)relOffset, sourceIndex);
  }

  /////////////////////////////////////
  // table switch support /////////////
  /////////////////////////////////////

  /**
   * An OFFSET instruction is not really an instruction; it is rather
   * an address (of an instruction) that is written into the binary
   * code.  These are used to build a table of addresses for table
   * switches.  The code for tableswitches first calculates the address of the
   * start of the method. Using this address a branch relative to the start
   * of the method is computed by loading the offset from the start of the
   * method for a particular switch case. The OFFSET instruction is encoding
   * one value in the table.
   *
   * This mechanism assumes code for emitting tableswitch looks as
   * follows; it is not very nice, but is improved on X86 64 with the addition
   * of RIP displacement addressing. The GNU tools generate something.
   * Note that default cases must be handled separately. </P>
   *
   * <PRE>
   *     T0 = getPCThunk() or RIP less offset from start of method
   *     T0 += [T0 + m<<2 + tableDisplacement]
   *     JMP T0
   * tableDisplacement:
   *     OFFSET 0 (case 0 target)
   *     OFFSET 1 (case 1 target)
   *     ...
   *     OFFSET n (case n target)
   * </PRE>
   *
   * @see #patchSwitchCase
   *
   * @param c the table entry being emitted (i.e. the value of the
   * switch expression corresponding to this target)
   * @param mTarget the method-relative target offset
   * @param bTarget the label associated with the branch target instrucion
   */
  public final void emitOFFSET_Imm_ImmOrLabel(int c, int mTarget, int bTarget) {
    int miStart = mi;
    if (0 < mTarget) { // resolved (backward) reference
      emitImm32(mTarget);
      if (lister != null) lister.I(miStart, "DATA", mTarget);
    } else {        // unresolved forward reference
      ForwardReference r =  new ForwardReference.SwitchCase(mi, bTarget);
      forwardRefs = ForwardReference.enqueue(forwardRefs, r);
      emitImm32(c);
      if (lister != null) lister.I(miStart, "DATA", c);
    }
  }

  /**
   * Patch a tableswitch offset table entry at the given source
   * index.  This method resolves the table entry at the given source
   * index to point to the current instruction plus an aligning NOP.
   *
   * @see #emitOFFSET_Imm_ImmOrLabel
   *
   * @param sourceIndex the location of the offset to patch
   */
  public final void patchSwitchCase (int sourceIndex) {
    if (VM.AlignmentChecking || isHotCode()) {
      // force 4byte alignment here
      emitNOP((4 - mi) & 3);
    }
    if (lister != null) lister.comefrom(mi, sourceIndex);
    int c = 0;
    c |= (machineCodes[sourceIndex+0] & 0xFF) <<  0;
    c |= (machineCodes[sourceIndex+1] & 0xFF) <<  8;
    c |= (machineCodes[sourceIndex+2] & 0xFF) << 16;
    c |= (machineCodes[sourceIndex+3] & 0xFF) << 24;  // c = case index
    emitImm32(mi, sourceIndex); // write mi to sourceIndex
  }

  /**
   * Patch the instruction that will load the displacement to the offset table
   * from the start of the method assuming that the next code to be created is
   * the offset table.
   *
   * @param toPatchAddress the address of the instruction that performs the
   *    displacement load
   */
  public final void patchSwitchTableDisplacement(int toPatchAddress) {
    if (VM.buildFor32Addr()) {
      // the instruction to patch is an reg = [reg + idx<<scale + disp]
      emitImm32(mi, toPatchAddress+3);
    } else {
      // the instruction to patch is an reg = [reg + idx<<scale + disp]
      emitImm32(mi, toPatchAddress+3);
    }
  }

  /////////////////////////////////////
  // instructions (hand coded)       //
  /////////////////////////////////////

  public final void emitMFENCE() {
  	int miStart = mi;
    emitLockNextInstruction();
    emitADD_RegInd_Imm(ESP, 0);
    /**
     * The above has the same semantics, but with better performance as a true MFENCE:
     * setMachineCodes(mi++,(byte) 0x0F);
     * setMachineCodes(mi++,(byte) 0xAE);
     * setMachineCodes(mi++,(byte) 0xF0);
     * if (lister != null) lister.OP(miStart, "MFENCE");
     */
  }

  /**
   * Generate a bswap on a register. That is,
   * <PRE>
   * bswap reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBSWAP_Reg(GPR reg) {
    int miStart = mi;
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) (0xC8 | (reg.value() & 7)));
    if (lister != null) lister.R(miStart, "bswap", reg);
  }

  /**
   * Generate a bswap on a quad register. That is,
   * <PRE>
   * bswap reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBSWAP_Reg_Quad(GPR reg) {
    int miStart = mi;
    generateREXprefix(true, null, null, reg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) (0xC8 | (reg.value() & 7)));
    if (lister != null) lister.R(miStart, "bswap", reg);
  }

  /**
   * Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = src
   * </PRE>
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  public final void emitCMOV_Cond_Reg_Reg(byte cond, GPR dst, GPR src) {
    int miStart = mi;
    generateREXprefix(false, dst, null, src);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x40, cond);
    emitRegRegOperands(src, dst);
    if (lister != null) lister.RR(miStart, "CMOV" + CONDITION[cond], dst, src);
  }

  /**
   * Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = [src + disp]
   * </PRE>
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  public final void emitCMOV_Cond_Reg_RegDisp(byte cond, GPR dst, GPR src, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, dst, null, src);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x40, cond);
    emitRegDispRegOperands(src, disp, dst);
    if (lister != null) lister.RRD(miStart, "CMOV" + CONDITION[cond], dst, src, disp);
  }

  /**
   * Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = [src]
   * </PRE>
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  public final void emitCMOV_Cond_Reg_RegInd(byte cond, GPR dst, GPR src) {
    int miStart = mi;
    generateREXprefix(false, dst, null, src);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x40, cond);
    emitRegIndirectRegOperands(src, dst);
    if (lister != null) lister.RRN(miStart, "CMOV" + CONDITION[cond], dst, src);
  }

  /**
   * Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = [index2<<scale2 + disp2]
   * </PRE>
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  public final void emitCMOV_Cond_Reg_RegOff(byte cond, GPR dst, GPR index2, short scale2, Offset disp2) {
    int miStart = mi;
    generateREXprefix(false, dst, index2, null);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x40, cond);
    emitRegOffRegOperands(index2, scale2, disp2, dst);
    if (lister != null) lister.RRFD(miStart, "CMOV" + CONDITION[cond], dst, index2, scale2, disp2);
  }

  /**
   * Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = [disp2]
   * </PRE>
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitCMOV_Cond_Reg_Abs(byte cond, GPR dst, Address disp2) {
    int miStart = mi;
    generateREXprefix(false, dst, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x40, cond);
    emitAbsRegOperands(disp2, dst);
    if (lister != null) lister.RRA(miStart, "CMOV" + CONDITION[cond], dst, disp2);
  }

  /**
   * Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = [base2 + index2<<scale2 + disp2]
   * </PRE>
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3,4})
  public final void emitCMOV_Cond_Reg_RegIdx(byte cond, GPR dst, GPR base2, GPR index2, short scale2, Offset disp2) {
    int miStart = mi;
    generateREXprefix(false, dst, index2, base2);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x40, cond);
    emitSIBRegOperands(base2, index2, scale2, disp2, dst);
    if (lister != null) lister.RRXD(miStart, "CMOV" + CONDITION[cond], dst, base2, index2, scale2, disp2);
  }

  /**
   * Set destination to zero or one, if the given condition is false
   * or true, respectively.  That is,
   * <PRE>
   * dst = (cond)? 1: 0
   * </PRE>
   *
   * @param cond the condition to be tested
   * @param dst the destination register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSET_Cond_Reg_Byte(byte cond, GPR dst) {
    int miStart = mi;
    generateREXprefix(false, null, null, dst);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x90, cond);
    emitRegRegOperands(dst, EAX /* UNUSED */);
    if (lister != null) lister.R(miStart, "SET" + CONDITION[cond], dst);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSET_Cond_RegDisp_Byte(byte cond, GPR dst, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, null, null, dst);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x90, cond);
    emitRegDispRegOperands(dst, disp, EAX /* UNUSED */);
    if (lister != null) lister.RD(miStart, "SET" + CONDITION[cond], dst, disp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSET_Cond_RegInd_Byte(byte cond, GPR dst) {
    int miStart = mi;
    generateREXprefix(false, null, null, dst);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x90, cond);
    emitRegIndirectRegOperands(dst, EAX /* UNUSED */);
    if (lister != null) lister.RN(miStart, "SET" + CONDITION[cond], dst);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  public final void emitSET_Cond_RegIdx_Byte(byte cond, GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x90, cond);
    emitSIBRegOperands(base, index, scale, disp, EAX /* UNUSED */);
    if (lister != null) lister.RXD(miStart, "SET" + CONDITION[cond], base, index, scale, disp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSET_Cond_RegOff_Byte(byte cond, GPR index, short scale, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x90, cond);
    emitRegOffRegOperands(index, scale, disp, EAX /* UNUSED */);
    if (lister != null) lister.RFD(miStart, "SET" + CONDITION[cond], index, scale, disp);
  }

  @Inline
  public final void emitSET_Cond_Abs_Byte(byte cond, Address disp) {
    int miStart = mi;
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x90, cond);
    emitAbsRegOperands(disp, EAX /* UNUSED */);
    if (lister != null) lister.RA(miStart, "SET" + CONDITION[cond], disp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL2_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "IMUL", dstReg, srcReg);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL2_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "IMUL", dstReg, srcBase);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL2_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "IMUL", dstReg, srcBase, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL2_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "IMUL", dstReg, srcIndex, srcScale, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitIMUL2_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "IMUL", dstReg, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL2_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "IMUL", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitIMUL2_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x6B);
      emitRegRegOperands(dstReg, dstReg);
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x69);
      emitRegRegOperands(dstReg, dstReg);
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "IMUL", dstReg, imm);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL2_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "IMUL", dstReg, srcReg);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL2_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "IMUL", dstReg, srcBase);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL2_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "IMUL", dstReg, srcBase, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL2_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "IMUL", dstReg, srcIndex, srcScale, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitIMUL2_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "IMUL", dstReg, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL2_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAF);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "IMUL", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitIMUL2_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, null);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x6B);
      emitRegRegOperands(dstReg, dstReg);
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x69);
      emitRegRegOperands(dstReg, dstReg);
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "IMUL", dstReg, imm);
  }

  // trap
  public final void emitINT_Imm (int v) {
    if (VM.VerifyAssertions) VM._assert(v <= 0xFF);
    int miStart = mi;
    if (v == 3) { // special case interrupt
      setMachineCodes(mi++, (byte) 0xCC);
    } else {
      setMachineCodes(mi++, (byte) 0xCD);
      setMachineCodes(mi++, (byte) v);
    }
    if (lister != null) lister.I(miStart, "INT", v);
  }

  /**
   * Conditionally branch to the given target, i.e.
   * <PRE>
   * if (cond) then IP = (instruction @ label)
   * </PRE>
   *
   * This emit method is expecting only a forward branch (that is
   * what the Label operand means); it creates a ForwardReference
   * to the given label, and puts it into the assembler's list of
   * references to resolve.  This emiiter knows it emits conditional
   * branches, so it uses ForwardReference.ConditionalBranch as the
   * forward reference type to create.
   *
   * All forward branches have a label as the branch target; clients
   * can arbirarily associate labels and instructions, but must be
   * consistent in giving the chosen label as the target of branches
   * to an instruction and calling resolveForwardBranches with the
   * given label immediately before emitting the target instruction.
   * See the header comments of ForwardReference for more details.
   *
   * @param cond the IA32 ISA condition code bits to mask into opcode
   * @param label the label associated with the branch target instrucion
   *
   * @see org.jikesrvm.compilers.common.assembler.ForwardReference.ConditionalBranch
   */
  public final void emitJCC_Cond_Label (byte cond, int label) {
    int miStart = mi;
    ForwardReference r =  new ForwardReference.ConditionalBranch(mi, label);
    forwardRefs = ForwardReference.enqueue(forwardRefs, r);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) (0x80 + cond));
    mi += 4; // leave space for displacement    TODO!! handle short branches
    if (lister != null) lister.I(miStart, "J" + CONDITION[cond], label);
  }

  /**
   * Conditionally branch to the given target, i.e.
   * <PRE>
   * if (cond) then IP = mTarget
   * </PRE>
   *
   * This emit method emits only backward branches (that is what
   * branching to an Imm operand means), so it simply writes the
   * appropriate binary code without bothering with the forward
   * reference mechanism.
   *
   * @param cond the IA32 ISA condition code bits to mask into opcode
   * @param mTarget the method-relative target offset
   */
  public final void emitJCC_Cond_Imm (byte cond, int mTarget) {
    int miStart = mi;
    int relOffset = mTarget - (mi + 1 + 1); // address relative to next instruction
    if (fits(relOffset, 8)) {
      emitCondOpByte((byte)0x70, cond);
      emitImm8((byte)relOffset);
    } else {
    setMachineCodes(mi++, (byte) 0x0F);
    emitCondOpByte((byte)0x80, cond);
    relOffset = mTarget - (mi + 4); // address relative to next instruction
    emitImm32(relOffset);
    }
    if (lister != null) lister.I(miStart, "J" + CONDITION[cond], relOffset);
  }

  /**
   * Conditionally branch to the given target, i.e.
   * <PRE>
   * if (cond) then IP = mTarget -or- (instruction @ bTarget)
   * </PRE>
   *
   * This emit method represents a branch that could be either
   * forward or backward; it simply calls either the Label or Imm
   * emit method.
   *
   * @see #emitJCC_Cond_Label
   * @see #emitJCC_Cond_Imm
   *
   * @param cond the IA32 ISA condition code bits to mask into opcode
   * @param mTarget the method-relative target offset
   * @param bTarget the label associated with the branch target instrucion
   */
  public final void emitJCC_Cond_ImmOrLabel (byte cond, int mTarget, int bTarget) {
    if (mTarget == 0) { // forward branch
      emitJCC_Cond_Label(cond, bTarget);
    } else { // backward branch
      emitJCC_Cond_Imm(cond, mTarget);
    }
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitLEA_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x8D);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "LEA", dstReg, srcBase, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitLEA_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x8D);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "LEA", dstReg, srcBase);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitLEA_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x8D);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "LEA", dstReg, srcIndex, srcScale, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitLEA_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x8D);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "LEA", dstReg, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitLEA_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x8D);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "LEA", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitLEA_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x8D);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "LEA", dstReg, srcBase, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitLEA_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x8D);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "LEA", dstReg, srcBase);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitLEA_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x8D);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "LEA", dstReg, srcIndex, srcScale, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitLEA_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x8D);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "LEA", dstReg, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitLEA_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x8D);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "LEA", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) (0xB8 | dstReg.value()));
    emitImm32(imm);
    if (lister != null) lister.RI(miStart, "MOV", dstReg, imm);
  }

  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_Reg_Imm_Quad(GPR dstReg, long imm) {
    int miStart = mi;
    generateREXprefix(true, null, null, dstReg);
    setMachineCodes(mi++, (byte) (0xB8 | dstReg.value()));
    emitImm64(imm);
    if (lister != null) lister.RI(miStart, "MOV", dstReg, imm);
  }

  /** pop address and goto it */
  public final void emitRET () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xC3);
    if (lister != null) lister.OP(miStart, "RET");
  }

  /** pop address and goto it, pop parameterBytes additional bytes */
  public final void emitRET_Imm (int parameterBytes) {
    int miStart = mi;
    if (parameterBytes == 0) {
      setMachineCodes(mi++, (byte) 0xC3);
      if (lister != null) lister.OP(miStart, "RET");
    } else {
      setMachineCodes(mi++, (byte) 0xC2);
      emitImm16(parameterBytes);
      if (VM.VerifyAssertions) VM._assert ((parameterBytes & 0xffff0000) == 0);
      if (lister != null) lister.I(miStart, "RET", parameterBytes);
    }
  }

  /** allocate stack frame for procedure */
  public final void emitENTER_Imm (int frameSize) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xC8);
    emitImm16(frameSize);
    setMachineCodes(mi++, (byte) 0x0);
    if (lister != null) lister.I(miStart, "ENTER", frameSize);
  }

  /** sign extends EAX into EDX */
  public final void emitCDQ () {
    int miStart = mi;
    setMachineCodes(mi++, (byte)0x99);
    if (lister != null) lister.OP(miStart, "CDQ");
  }

  /** sign extends RAX into RDX */
  public final void emitCDO () {
    int miStart = mi;
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte)0x99);
    if (lister != null) lister.OP(miStart, "CDO");
  }

  /** sign extends EAX into RDX */
  public final void emitCDQE () {
    int miStart = mi;
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte)0x98);
    if (lister != null) lister.OP(miStart, "CDQE");
  }

  /**
   * Read time stamp into edx:eax, on Linux this appears to be unprivileged.
   * <pre>
   * edx:eax <- time stamp counter
   * </pre>
   */
  public final void emitRDTSC() {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x31);
    if (lister != null) lister.OP(miStart, "RDTSC");
  }

  /** software prefetch */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPREFETCHNTA_Reg(GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++,(byte) 0x18);
    emitRegIndirectRegOperands(srcReg, GPR.getForOpcode(0));
    if (lister != null) lister.R(miStart, "PREFETCHNTA", srcReg);
  }

  /** Suggest to process that a a compare for a spin lock has just failed */
  public final void emitPAUSE () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    setMachineCodes(mi++,(byte) 0x90);
    if (lister != null) lister.OP(miStart, "PAUSE");
  }

  /**
   * Compare and exchange 8 bytes
   * <PRE>
   * cmpxchg8b [dst + disp]
   * </PRE>
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPXCHG8B_RegDisp(GPR base, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(1));
    if (lister != null) lister.RD(miStart, "CMPXCHG8B" , base, disp);
  }

  /**
   * Compare and exchange 8 bytes
   * <PRE>
   * cmpxchg8b [dst]
   * </PRE>
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPXCHG8B_RegInd(GPR base) {
    int miStart = mi;
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegIndirectRegOperands(base, GPR.getForOpcode(1));
    if (lister != null) lister.R(miStart, "CMPXCHG8B" , base);
  }

  /**
   * Compare and exchange 8 bytes
   * <PRE>
   * cmpxchg8b [index2<<scale2 + disp2]
   * </PRE>
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPXCHG8B_RegOff(GPR index2, short scale2, Offset disp2) {
    int miStart = mi;
    generateREXprefix(false, null, index2, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegOffRegOperands(index2, scale2, disp2, GPR.getForOpcode(1));
    if (lister != null) lister.RFD(miStart, "CMPXCHG8B", index2, scale2, disp2);
  }

  /**
   * Compare and exchange 8 bytes
   * <PRE>
   * cmpxchg8b [base + index2<<scale2 + disp2]
   * </PRE>
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPXCHG8B_RegIdx(GPR base2, GPR index2, short scale2, Offset disp2) {
    int miStart = mi;
    generateREXprefix(false, null, index2, base2);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC7);
    emitSIBRegOperands(base2, index2, scale2, disp2, GPR.getForOpcode(1));
    if (lister != null) lister.RXD(miStart, "CMPXCHG8B", base2, index2, scale2, disp2);
  }

  /** Store AH into Flags */
  public final void emitSAHF () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9E);
    if (lister != null) lister.OP(miStart, "SAHF");
  }

  /**
   * Emit NOP instruction
   *
   * @param length size of NOP instruction required
   */
  public final void emitNOP (int length) {
    int miStart = mi;
    switch (length) {
    case 0:
      break;
    case 1:
      setMachineCodes(mi++, (byte) 0x90);
      break;
    case 2:
      setMachineCodes(mi++, (byte) 0x66);
      setMachineCodes(mi++, (byte) 0x90);
      break;
    case 3:
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0x1F);
      setMachineCodes(mi++, (byte) 0x00);
      break;
    case 4:
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0x1F);
      setMachineCodes(mi++, (byte) 0x40);
      setMachineCodes(mi++, (byte) 0x00);
      break;
    case 5:
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0x1F);
      setMachineCodes(mi++, (byte) 0x44);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      break;
    case 6:
      setMachineCodes(mi++, (byte) 0x66);
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0x1F);
      setMachineCodes(mi++, (byte) 0x44);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      break;
    case 7:
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0x1F);
      setMachineCodes(mi++, (byte) 0x80);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      break;
    case 8:
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0x1F);
      setMachineCodes(mi++, (byte) 0x84);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      break;
    case 9:
      setMachineCodes(mi++, (byte) 0x66);
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0x1F);
      setMachineCodes(mi++, (byte) 0x84);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      setMachineCodes(mi++, (byte) 0x00);
      break;
    default:
      throw new Error("Unexpected NOP length "+length);
    }
    if (lister != null) lister.OP(miStart, "NOP");
  }

  ////////////////////////////////////////////
  // hand-coded floating point instructions //
  ////////////////////////////////////////////

  /**
   * Empty MMX technology state
   * <PRE>
   * emms
   * </PRE>
   */
  public final void emitEMMS() {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0x77);
      if (lister != null) lister.OP(miStart, "EMMS");
  }

  /** x87 floating point conditional moves */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  public final void emitFCMOV_Cond_Reg_Reg(byte cond, FPR reg1, FPR reg2) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(reg1 == FP0);
    switch (cond) {
      case LLT:
        setMachineCodes(mi++, (byte) 0xDA);
        setMachineCodes(mi++, (byte) (0xC0 + reg2.value()));
        break;
      case EQ:
        setMachineCodes(mi++, (byte) 0xDA);
        setMachineCodes(mi++, (byte) (0xC8 + reg2.value()));
        break;
      case LLE:
        setMachineCodes(mi++, (byte) 0xDA);
        setMachineCodes(mi++, (byte) (0xD0 + reg2.value()));
        break;
      case PE:
        setMachineCodes(mi++, (byte) 0xDA);
        setMachineCodes(mi++, (byte) (0xD8 + reg2.value()));
        break;
      case LGE:
        setMachineCodes(mi++, (byte) 0xDB);
        setMachineCodes(mi++, (byte) (0xC0 + reg2.value()));
        break;
      case NE:
        setMachineCodes(mi++, (byte) 0xDB);
        setMachineCodes(mi++, (byte) (0xC8 + reg2.value()));
        break;
      case LGT:
        setMachineCodes(mi++, (byte) 0xDB);
        setMachineCodes(mi++, (byte) (0xD0 + reg2.value()));
        break;
      case PO:
        setMachineCodes(mi++, (byte) 0xDB);
        setMachineCodes(mi++, (byte) (0xD8 + reg2.value()));
        break;
      default:
        if (VM.VerifyAssertions) VM._assert(VM.NOT_REACHED);
    }
    if (lister != null) lister.RR(miStart, "FCMOV" + CONDITION[cond], reg1, reg2);
  }

  /** x87 floating point push of ST(i) into ST(0) */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFLD_Reg_Reg(FPR destReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(destReg == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) (0xC0 + srcReg.value()));
    if (lister != null) lister.R(miStart, "FLD", srcReg);
  }

  // floating point copy of ST(0) into ST(I)
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFST_Reg_Reg(FPR destReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    setMachineCodes(mi++, (byte) (0xD0 + destReg.value()));
    if (lister != null) lister.R(miStart, "FST", destReg);
  }

  // floating point pop of ST(0) into ST(I)
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSTP_Reg_Reg(FPR destReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    setMachineCodes(mi++, (byte) (0xD8 + destReg.value()));
    if (lister != null) lister.R(miStart, "FST", destReg);
  }

  // Change Sign: Top of FPU register stack -= Top og FPU register stack
  public final void emitFCHS () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xE0);
    if (lister != null) lister.OP(miStart, "FADD32");
  }

  public final void emitFUCOMPP () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xDA);
    setMachineCodes(mi++, (byte) 0xE9);
    if (lister != null) lister.OP(miStart, "FUCOMPP");
  }

  // Store Status Word into AX register/noexecptions
  public final void emitFNSTSW () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xDF);
    setMachineCodes(mi++, (byte) 0xE0);
    if (lister != null) lister.OP(miStart, "FNSTSW");
  }

  // Real Remainder:
  // Top of FPU register stack <- ST(0) - (Q*ST(1)
  // Q is the interger value obtained from truncating
  // ST(0)/ST(1) toward 0
  public final void emitFPREM () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xF8);
    if (lister != null) lister.OP(miStart, "FPREM");
  }

  // Blow away floating point state
  public final void emitFINIT() {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xDB);
    setMachineCodes(mi++, (byte) 0xE3);
    if (lister != null) lister.OP(miStart, "FINIT");
  }

  // Blow away floating point state
  // Pending exceptions??? Don't tell me about pending exceptions!!
  public final void emitFNINIT() {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xDB);
    setMachineCodes(mi++, (byte) 0xE3);
    if (lister != null) lister.OP(miStart, "FNINIT");
  }

  /** Declare we are no longer using FP register */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFFREE_Reg(FPR reg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xDD);
    setMachineCodes(mi++, (byte) ( (byte)0xC0 + reg.value() ));
    if (lister != null) lister.R(miStart, "FFREE", reg);
  }

  /** The dreaded FXCH (symbol of all that's wrong with x87 floating point) */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFXCH_Reg_Reg(FPR regOne, FPR regTwo) {
    int miStart = mi;

    // at least one reg must not be FP0
    FPR nonZeroReg = FP0; // :)
    if (regOne == FP0 && regTwo == FP0)
      // do nothing; this is stupid
      return;
    else if (regOne == FP0 && regTwo != FP0)
      nonZeroReg = regTwo;
    else if (regTwo == FP0 && regOne != FP0)
      nonZeroReg = regOne;

    // if not, bad instruction, so die
    if (nonZeroReg == FP0)
      VM._assert(false, "FXCH of " + regOne + ", " + regTwo);

    // generate it, with special case (of course) for FP1
    setMachineCodes(mi++, (byte) 0xD9);
    if (nonZeroReg == FP1)
      setMachineCodes(mi++, (byte) 0xC9);
    else
      setMachineCodes(mi++, (byte) (0xC8 | nonZeroReg.value()));

    // list it
    if (lister != null) lister.R(miStart, "FXCH", nonZeroReg);
  }

  /*
   * BELOW HERE ARE AUTOMATICALLY-GENERATED INSTRUCTIONS.  DO NOT EDIT.
   *
   * These instructions are generated by genAssembler.sh in the
   * src-generated/ia32-assembler directory.  Please make all needed
   * edits to that script.
   */
  /**
   * Generate a register(indirect)--register ADC. That is,
   * <PRE>
   * [dstBase] +CF=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "ADC", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register ADC. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] +CF=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitADC_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "ADC", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register ADC. That is,
   * <PRE>
   * [dstDisp] +CF=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitADC_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "ADC", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register ADC. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +CF=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitADC_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "ADC", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ADC. That is,
   * <PRE>
   * [dstBase + dstDisp] +CF=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitADC_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "ADC", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register ADC. That is,
   * <PRE>
   * dstReg +CF=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "ADC", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ADC. That is,
   * <PRE>
   * dstReg +CF=  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ADC", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ADC", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ADC", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitADC_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ADC", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) ADC. That is,
   * <PRE>
   * dstReg +CF=  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ADC", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register ADC. That is,
   * <PRE>
   * [dstBase] +CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "ADC", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register ADC. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] +CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitADC_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "ADC", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register ADC. That is,
   * <PRE>
   * [dstDisp] +CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitADC_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "ADC", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register ADC. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitADC_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "ADC", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ADC. That is,
   * <PRE>
   * [dstBase + dstDisp] +CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitADC_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "ADC", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register ADC. That is,
   * <PRE>
   * dstReg +CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "ADC", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ADC. That is,
   * <PRE>
   * dstReg +CF=  (word)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ADC", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  (word)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ADC", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  (word)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ADC", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  (word)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitADC_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ADC", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) ADC. That is,
   * <PRE>
   * dstReg +CF=  (word)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ADC", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register ADC. That is,
   * <PRE>
   * [dstBase] +CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "ADC", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register ADC. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] +CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitADC_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "ADC", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register ADC. That is,
   * <PRE>
   * [dstDisp] +CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitADC_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "ADC", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register ADC. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitADC_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "ADC", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ADC. That is,
   * <PRE>
   * [dstBase + dstDisp] +CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitADC_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "ADC", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register ADC. That is,
   * <PRE>
   * dstReg +CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x11);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "ADC", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ADC. That is,
   * <PRE>
   * dstReg +CF=  (quad)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ADC", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ADC", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ADC", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  (quad)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitADC_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ADC", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) ADC. That is,
   * <PRE>
   * dstReg +CF=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x13);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ADC", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register ADC. That is,
   * <PRE>
   * [dstBase] +CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x10);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "ADC", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register ADC. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] +CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitADC_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x10);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "ADC", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register ADC. That is,
   * <PRE>
   * [dstDisp] +CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitADC_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x10);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "ADC", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register ADC. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitADC_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x10);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "ADC", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ADC. That is,
   * <PRE>
   * [dstBase + dstDisp] +CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitADC_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x10);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "ADC", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register ADC. That is,
   * <PRE>
   * dstReg +CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x10);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "ADC", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ADC. That is,
   * <PRE>
   * dstReg +CF=  (byte)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x12);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ADC", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  (byte)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x12);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ADC", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  (byte)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x12);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ADC", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset ADC. That is,
   * <PRE>
   * dstReg +CF=  (byte)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitADC_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x12);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ADC", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) ADC. That is,
   * <PRE>
   * dstReg +CF=  (byte)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x12);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ADC", dstReg, srcBase);
  }

  /**
   * Generate a register--immediate ADC. That is,
   * <PRE>
   * dstReg +CF=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x15);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "ADC", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate ADC. That is,
   * <PRE>
   * [dstBase + dstDisp] +CF=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "ADC", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ADC. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] +CF=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "ADC", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ADC. That is,
   * <PRE>
   * [dstDisp] +CF=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitADC_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "ADC", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ADC. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +CF=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "ADC", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate ADC. That is,
   * <PRE>
   * [dstBase] +CF=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "ADC", dstBase, imm);
  }

  /**
   * Generate a register--immediate ADC. That is,
   * <PRE>
   * dstReg +CF=  (word)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x15);
      emitImm16(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm16(imm);
    }
    if (lister != null) lister.RI(miStart, "ADC", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate ADC. That is,
   * <PRE>
   * [dstBase + dstDisp] +CF=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
      emitImm16(imm);
    }
    if (lister != null) lister.RDI(miStart, "ADC", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ADC. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] +CF=  (word)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm16(imm);
    }
    if (lister != null) lister.RFDI(miStart, "ADC", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ADC. That is,
   * <PRE>
   * [dstDisp] +CF=  (word)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitADC_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
      emitImm16(imm);
    }
    if (lister != null) lister.RAI(miStart, "ADC", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ADC. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +CF=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm16(imm);
    }
    if (lister != null) lister.RXDI(miStart, "ADC", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate ADC. That is,
   * <PRE>
   * [dstBase] +CF=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
      emitImm16(imm);
    }
    if (lister != null) lister.RNI(miStart, "ADC", dstBase, imm);
  }

  /**
   * Generate a register--immediate ADC. That is,
   * <PRE>
   * dstReg +CF=  (quad)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x15);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "ADC", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate ADC. That is,
   * <PRE>
   * [dstBase + dstDisp] +CF=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "ADC", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ADC. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] +CF=  (quad)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "ADC", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ADC. That is,
   * <PRE>
   * [dstDisp] +CF=  (quad)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitADC_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "ADC", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ADC. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +CF=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "ADC", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate ADC. That is,
   * <PRE>
   * [dstBase] +CF=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x2" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x2" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "ADC", dstBase, imm);
  }

  /**
   * Generate a register--immediate ADC. That is,
   * <PRE>
   *  dstReg +CF= (byte) imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x14);
      emitImm8(imm);
    } else {
      generateREXprefix(false, null, null, dstReg);
      setMachineCodes(mi++, (byte) 0x80);
      // "register 0x2" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm8(imm);
    }
    if (lister != null) lister.RI(miStart, "ADC", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate ADC. That is,
   * <PRE>
   * [dstBase + dstDisp] +CF= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x2" is really part of the opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
    emitImm8(imm);
    if (lister != null) lister.RDI(miStart, "ADC", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ADC. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] +CF= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADC_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x2" is really part of the opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    emitImm8(imm);
    if (lister != null) lister.RXDI(miStart, "ADC", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ADC. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] +CF= (byte) imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x2" is really part of the opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    emitImm8(imm);
    if (lister != null) lister.RFDI(miStart, "ADC", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ADC. That is,
   * <PRE>
   * [dstDisp] +CF= (byte) imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitADC_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x2" is really part of the opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
    emitImm8(imm);
    if (lister != null) lister.RAI(miStart, "ADC", dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate ADC. That is,
   * <PRE>
   * [dstBase] +CF= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADC_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x2" is really part of the opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
    emitImm8(imm);
    if (lister != null) lister.RNI(miStart, "ADC", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register ADD. That is,
   * <PRE>
   * [dstBase] +=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "ADD", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register ADD. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] +=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitADD_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "ADD", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register ADD. That is,
   * <PRE>
   * [dstDisp] +=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitADD_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "ADD", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register ADD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitADD_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "ADD", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ADD. That is,
   * <PRE>
   * [dstBase + dstDisp] +=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitADD_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "ADD", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register ADD. That is,
   * <PRE>
   * dstReg +=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "ADD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ADD. That is,
   * <PRE>
   * dstReg +=  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ADD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ADD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ADD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitADD_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ADD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) ADD. That is,
   * <PRE>
   * dstReg +=  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ADD", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register ADD. That is,
   * <PRE>
   * [dstBase] +=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "ADD", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register ADD. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] +=  (word)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitADD_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "ADD", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register ADD. That is,
   * <PRE>
   * [dstDisp] +=  (word)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitADD_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "ADD", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register ADD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitADD_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "ADD", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ADD. That is,
   * <PRE>
   * [dstBase + dstDisp] +=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitADD_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "ADD", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register ADD. That is,
   * <PRE>
   * dstReg +=  (word)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "ADD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ADD. That is,
   * <PRE>
   * dstReg +=  (word)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ADD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  (word)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ADD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  (word)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ADD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  (word)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitADD_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ADD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) ADD. That is,
   * <PRE>
   * dstReg +=  (word)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ADD", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register ADD. That is,
   * <PRE>
   * [dstBase] +=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "ADD", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register ADD. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] +=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitADD_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "ADD", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register ADD. That is,
   * <PRE>
   * [dstDisp] +=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitADD_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "ADD", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register ADD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitADD_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "ADD", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ADD. That is,
   * <PRE>
   * [dstBase + dstDisp] +=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitADD_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "ADD", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register ADD. That is,
   * <PRE>
   * dstReg +=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x01);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "ADD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ADD. That is,
   * <PRE>
   * dstReg +=  (quad)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ADD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ADD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ADD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  (quad)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitADD_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ADD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) ADD. That is,
   * <PRE>
   * dstReg +=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x03);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ADD", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register ADD. That is,
   * <PRE>
   * [dstBase] +=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x00);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "ADD", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register ADD. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] +=  (byte)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitADD_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x00);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "ADD", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register ADD. That is,
   * <PRE>
   * [dstDisp] +=  (byte)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitADD_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x00);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "ADD", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register ADD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitADD_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x00);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "ADD", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ADD. That is,
   * <PRE>
   * [dstBase + dstDisp] +=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitADD_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x00);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "ADD", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register ADD. That is,
   * <PRE>
   * dstReg +=  (byte)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x00);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "ADD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ADD. That is,
   * <PRE>
   * dstReg +=  (byte)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x02);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ADD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  (byte)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x02);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ADD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  (byte)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x02);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ADD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset ADD. That is,
   * <PRE>
   * dstReg +=  (byte)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitADD_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x02);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ADD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) ADD. That is,
   * <PRE>
   * dstReg +=  (byte)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x02);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ADD", dstReg, srcBase);
  }

  /**
   * Generate a register--immediate ADD. That is,
   * <PRE>
   * dstReg +=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x05);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "ADD", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate ADD. That is,
   * <PRE>
   * [dstBase + dstDisp] +=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "ADD", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ADD. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] +=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "ADD", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ADD. That is,
   * <PRE>
   * [dstDisp] +=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitADD_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "ADD", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ADD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "ADD", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate ADD. That is,
   * <PRE>
   * [dstBase] +=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "ADD", dstBase, imm);
  }

  /**
   * Generate a register--immediate ADD. That is,
   * <PRE>
   * dstReg +=  (word)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x05);
      emitImm16(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RI(miStart, "ADD", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate ADD. That is,
   * <PRE>
   * [dstBase + dstDisp] +=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RDI(miStart, "ADD", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ADD. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] +=  (word)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RFDI(miStart, "ADD", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ADD. That is,
   * <PRE>
   * [dstDisp] +=  (word)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitADD_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RAI(miStart, "ADD", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ADD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RXDI(miStart, "ADD", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate ADD. That is,
   * <PRE>
   * [dstBase] +=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RNI(miStart, "ADD", dstBase, imm);
  }

  /**
   * Generate a register--immediate ADD. That is,
   * <PRE>
   * dstReg +=  (quad)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x05);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "ADD", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate ADD. That is,
   * <PRE>
   * [dstBase + dstDisp] +=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "ADD", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ADD. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] +=  (quad)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "ADD", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ADD. That is,
   * <PRE>
   * [dstDisp] +=  (quad)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitADD_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "ADD", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ADD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] +=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "ADD", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate ADD. That is,
   * <PRE>
   * [dstBase] +=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x0" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x0" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "ADD", dstBase, imm);
  }

  /**
   * Generate a register--immediate ADD. That is,
   * <PRE>
   *  dstReg += (byte) imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x04);
      emitImm8(imm);
    } else {
      generateREXprefix(false, null, null, dstReg);
      setMachineCodes(mi++, (byte) 0x80);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm8(imm);
    }
    if (lister != null) lister.RI(miStart, "ADD", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate ADD. That is,
   * <PRE>
   * [dstBase + dstDisp] += (byte) imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x0" is really part of the opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RDI(miStart, "ADD", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ADD. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] += (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADD_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x0" is really part of the opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RXDI(miStart, "ADD", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ADD. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] += (byte) imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x0" is really part of the opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RFDI(miStart, "ADD", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ADD. That is,
   * <PRE>
   * [dstDisp] += (byte) imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitADD_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x0" is really part of the opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RAI(miStart, "ADD", dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate ADD. That is,
   * <PRE>
   * [dstBase] += (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADD_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x0" is really part of the opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RNI(miStart, "ADD", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register AND. That is,
   * <PRE>
   * [dstBase] &=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "AND", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register AND. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] &=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitAND_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "AND", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register AND. That is,
   * <PRE>
   * [dstDisp] &=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitAND_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "AND", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register AND. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitAND_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "AND", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register AND. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitAND_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "AND", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register AND. That is,
   * <PRE>
   * dstReg &=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "AND", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement AND. That is,
   * <PRE>
   * dstReg &=  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "AND", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "AND", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "AND", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitAND_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "AND", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) AND. That is,
   * <PRE>
   * dstReg &=  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "AND", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register AND. That is,
   * <PRE>
   * [dstBase] &=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "AND", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register AND. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] &=  (word)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitAND_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "AND", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register AND. That is,
   * <PRE>
   * [dstDisp] &=  (word)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitAND_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "AND", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register AND. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitAND_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "AND", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register AND. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitAND_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "AND", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register AND. That is,
   * <PRE>
   * dstReg &=  (word)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "AND", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement AND. That is,
   * <PRE>
   * dstReg &=  (word)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "AND", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  (word)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "AND", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  (word)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "AND", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  (word)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitAND_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "AND", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) AND. That is,
   * <PRE>
   * dstReg &=  (word)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "AND", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register AND. That is,
   * <PRE>
   * [dstBase] &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "AND", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register AND. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitAND_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "AND", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register AND. That is,
   * <PRE>
   * [dstDisp] &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitAND_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "AND", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register AND. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitAND_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "AND", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register AND. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitAND_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "AND", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register AND. That is,
   * <PRE>
   * dstReg &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x21);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "AND", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement AND. That is,
   * <PRE>
   * dstReg &=  (quad)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "AND", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "AND", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "AND", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  (quad)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitAND_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "AND", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) AND. That is,
   * <PRE>
   * dstReg &=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x23);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "AND", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register AND. That is,
   * <PRE>
   * [dstBase] &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x20);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "AND", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register AND. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitAND_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x20);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "AND", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register AND. That is,
   * <PRE>
   * [dstDisp] &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitAND_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x20);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "AND", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register AND. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitAND_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x20);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "AND", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register AND. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitAND_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x20);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "AND", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register AND. That is,
   * <PRE>
   * dstReg &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x20);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "AND", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement AND. That is,
   * <PRE>
   * dstReg &=  (byte)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x22);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "AND", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  (byte)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x22);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "AND", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  (byte)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x22);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "AND", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset AND. That is,
   * <PRE>
   * dstReg &=  (byte)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitAND_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x22);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "AND", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) AND. That is,
   * <PRE>
   * dstReg &=  (byte)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x22);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "AND", dstReg, srcBase);
  }

  /**
   * Generate a register--immediate AND. That is,
   * <PRE>
   * dstReg &=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x25);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "AND", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate AND. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "AND", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate AND. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] &=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "AND", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate AND. That is,
   * <PRE>
   * [dstDisp] &=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitAND_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "AND", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate AND. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "AND", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate AND. That is,
   * <PRE>
   * [dstBase] &=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "AND", dstBase, imm);
  }

  /**
   * Generate a register--immediate AND. That is,
   * <PRE>
   * dstReg &=  (word)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x25);
      emitImm16(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm16(imm);
    }
    if (lister != null) lister.RI(miStart, "AND", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate AND. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm16(imm);
    }
    if (lister != null) lister.RDI(miStart, "AND", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate AND. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] &=  (word)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm16(imm);
    }
    if (lister != null) lister.RFDI(miStart, "AND", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate AND. That is,
   * <PRE>
   * [dstDisp] &=  (word)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitAND_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm16(imm);
    }
    if (lister != null) lister.RAI(miStart, "AND", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate AND. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm16(imm);
    }
    if (lister != null) lister.RXDI(miStart, "AND", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate AND. That is,
   * <PRE>
   * [dstBase] &=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm16(imm);
    }
    if (lister != null) lister.RNI(miStart, "AND", dstBase, imm);
  }

  /**
   * Generate a register--immediate AND. That is,
   * <PRE>
   * dstReg &=  (quad)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x25);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "AND", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate AND. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "AND", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate AND. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] &=  (quad)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "AND", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate AND. That is,
   * <PRE>
   * [dstDisp] &=  (quad)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitAND_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "AND", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate AND. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "AND", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate AND. That is,
   * <PRE>
   * [dstBase] &=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x4" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x4" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "AND", dstBase, imm);
  }

  /**
   * Generate a register--immediate AND. That is,
   * <PRE>
   *  dstReg &= (byte) imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x24);
      emitImm8(imm);
    } else {
      generateREXprefix(false, null, null, dstReg);
      setMachineCodes(mi++, (byte) 0x80);
      // "register 0x4" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8(imm);
    }
    if (lister != null) lister.RI(miStart, "AND", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate AND. That is,
   * <PRE>
   * [dstBase + dstDisp] &= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x4" is really part of the opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    emitImm8(imm);
    if (lister != null) lister.RDI(miStart, "AND", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate AND. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] &= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitAND_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x4" is really part of the opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    emitImm8(imm);
    if (lister != null) lister.RXDI(miStart, "AND", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate AND. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] &= (byte) imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x4" is really part of the opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    emitImm8(imm);
    if (lister != null) lister.RFDI(miStart, "AND", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate AND. That is,
   * <PRE>
   * [dstDisp] &= (byte) imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitAND_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x4" is really part of the opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    emitImm8(imm);
    if (lister != null) lister.RAI(miStart, "AND", dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate AND. That is,
   * <PRE>
   * [dstBase] &= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitAND_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x4" is really part of the opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    emitImm8(imm);
    if (lister != null) lister.RNI(miStart, "AND", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register CMP. That is,
   * <PRE>
   * [dstBase] ==  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "CMP", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register CMP. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] ==  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitCMP_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "CMP", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register CMP. That is,
   * <PRE>
   * [dstDisp] ==  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitCMP_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "CMP", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register CMP. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ==  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitCMP_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "CMP", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register CMP. That is,
   * <PRE>
   * [dstBase + dstDisp] ==  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitCMP_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "CMP", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register CMP. That is,
   * <PRE>
   * dstReg ==  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "CMP", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMP. That is,
   * <PRE>
   * dstReg ==  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CMP", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CMP", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CMP", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMP_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CMP", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) CMP. That is,
   * <PRE>
   * dstReg ==  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CMP", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register CMP. That is,
   * <PRE>
   * [dstBase] ==  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "CMP", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register CMP. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] ==  (word)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitCMP_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "CMP", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register CMP. That is,
   * <PRE>
   * [dstDisp] ==  (word)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitCMP_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "CMP", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register CMP. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ==  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitCMP_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "CMP", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register CMP. That is,
   * <PRE>
   * [dstBase + dstDisp] ==  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitCMP_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "CMP", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register CMP. That is,
   * <PRE>
   * dstReg ==  (word)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "CMP", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMP. That is,
   * <PRE>
   * dstReg ==  (word)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CMP", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  (word)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CMP", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  (word)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CMP", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  (word)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMP_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CMP", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) CMP. That is,
   * <PRE>
   * dstReg ==  (word)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CMP", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register CMP. That is,
   * <PRE>
   * [dstBase] ==  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "CMP", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register CMP. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] ==  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitCMP_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "CMP", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register CMP. That is,
   * <PRE>
   * [dstDisp] ==  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitCMP_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "CMP", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register CMP. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ==  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitCMP_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "CMP", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register CMP. That is,
   * <PRE>
   * [dstBase + dstDisp] ==  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitCMP_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "CMP", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register CMP. That is,
   * <PRE>
   * dstReg ==  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x39);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "CMP", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMP. That is,
   * <PRE>
   * dstReg ==  (quad)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CMP", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CMP", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CMP", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  (quad)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMP_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CMP", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) CMP. That is,
   * <PRE>
   * dstReg ==  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CMP", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register CMP. That is,
   * <PRE>
   * [dstBase] ==  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x38);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "CMP", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register CMP. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] ==  (byte)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitCMP_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x38);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "CMP", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register CMP. That is,
   * <PRE>
   * [dstDisp] ==  (byte)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitCMP_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x38);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "CMP", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register CMP. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ==  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitCMP_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x38);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "CMP", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register CMP. That is,
   * <PRE>
   * [dstBase + dstDisp] ==  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitCMP_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x38);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "CMP", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register CMP. That is,
   * <PRE>
   * dstReg ==  (byte)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x38);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "CMP", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMP. That is,
   * <PRE>
   * dstReg ==  (byte)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CMP", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  (byte)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CMP", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  (byte)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CMP", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset CMP. That is,
   * <PRE>
   * dstReg ==  (byte)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMP_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CMP", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) CMP. That is,
   * <PRE>
   * dstReg ==  (byte)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x3A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CMP", dstReg, srcBase);
  }

  /**
   * Generate a register--immediate CMP. That is,
   * <PRE>
   * dstReg ==  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x3D);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "CMP", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate CMP. That is,
   * <PRE>
   * [dstBase + dstDisp] ==  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "CMP", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate CMP. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] ==  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "CMP", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate CMP. That is,
   * <PRE>
   * [dstDisp] ==  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitCMP_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "CMP", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate CMP. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ==  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "CMP", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate CMP. That is,
   * <PRE>
   * [dstBase] ==  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "CMP", dstBase, imm);
  }

  /**
   * Generate a register--immediate CMP. That is,
   * <PRE>
   * dstReg ==  (word)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x3D);
      emitImm16(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm16(imm);
    }
    if (lister != null) lister.RI(miStart, "CMP", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate CMP. That is,
   * <PRE>
   * [dstBase + dstDisp] ==  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm16(imm);
    }
    if (lister != null) lister.RDI(miStart, "CMP", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate CMP. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] ==  (word)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm16(imm);
    }
    if (lister != null) lister.RFDI(miStart, "CMP", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate CMP. That is,
   * <PRE>
   * [dstDisp] ==  (word)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitCMP_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm16(imm);
    }
    if (lister != null) lister.RAI(miStart, "CMP", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate CMP. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ==  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm16(imm);
    }
    if (lister != null) lister.RXDI(miStart, "CMP", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate CMP. That is,
   * <PRE>
   * [dstBase] ==  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm16(imm);
    }
    if (lister != null) lister.RNI(miStart, "CMP", dstBase, imm);
  }

  /**
   * Generate a register--immediate CMP. That is,
   * <PRE>
   * dstReg ==  (quad)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x3D);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "CMP", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate CMP. That is,
   * <PRE>
   * [dstBase + dstDisp] ==  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "CMP", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate CMP. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] ==  (quad)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "CMP", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate CMP. That is,
   * <PRE>
   * [dstDisp] ==  (quad)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitCMP_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "CMP", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate CMP. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ==  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "CMP", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate CMP. That is,
   * <PRE>
   * [dstBase] ==  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x7" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x7" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "CMP", dstBase, imm);
  }

  /**
   * Generate a register--immediate CMP. That is,
   * <PRE>
   *  dstReg == (byte) imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x3C);
      emitImm8(imm);
    } else {
      generateREXprefix(false, null, null, dstReg);
      setMachineCodes(mi++, (byte) 0x80);
      // "register 0x7" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm8(imm);
    }
    if (lister != null) lister.RI(miStart, "CMP", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate CMP. That is,
   * <PRE>
   * [dstBase + dstDisp] == (byte) imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x7" is really part of the opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
    emitImm8(imm);
    if (lister != null) lister.RDI(miStart, "CMP", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate CMP. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] == (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMP_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x7" is really part of the opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    emitImm8(imm);
    if (lister != null) lister.RXDI(miStart, "CMP", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate CMP. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] == (byte) imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x7" is really part of the opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    emitImm8(imm);
    if (lister != null) lister.RFDI(miStart, "CMP", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate CMP. That is,
   * <PRE>
   * [dstDisp] == (byte) imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitCMP_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x7" is really part of the opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
    emitImm8(imm);
    if (lister != null) lister.RAI(miStart, "CMP", dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate CMP. That is,
   * <PRE>
   * [dstBase] == (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMP_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x7" is really part of the opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
    emitImm8(imm);
    if (lister != null) lister.RNI(miStart, "CMP", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register OR. That is,
   * <PRE>
   * [dstBase] |=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "OR", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register OR. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] |=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitOR_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "OR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register OR. That is,
   * <PRE>
   * [dstDisp] |=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitOR_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "OR", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register OR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] |=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitOR_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "OR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register OR. That is,
   * <PRE>
   * [dstBase + dstDisp] |=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitOR_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "OR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register OR. That is,
   * <PRE>
   * dstReg |=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "OR", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement OR. That is,
   * <PRE>
   * dstReg |=  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "OR", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "OR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "OR", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitOR_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "OR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) OR. That is,
   * <PRE>
   * dstReg |=  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "OR", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register OR. That is,
   * <PRE>
   * [dstBase] |=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "OR", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register OR. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] |=  (word)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitOR_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "OR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register OR. That is,
   * <PRE>
   * [dstDisp] |=  (word)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitOR_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "OR", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register OR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] |=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitOR_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "OR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register OR. That is,
   * <PRE>
   * [dstBase + dstDisp] |=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitOR_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "OR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register OR. That is,
   * <PRE>
   * dstReg |=  (word)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "OR", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement OR. That is,
   * <PRE>
   * dstReg |=  (word)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "OR", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  (word)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "OR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  (word)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "OR", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  (word)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitOR_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "OR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) OR. That is,
   * <PRE>
   * dstReg |=  (word)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "OR", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register OR. That is,
   * <PRE>
   * [dstBase] |=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "OR", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register OR. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] |=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitOR_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "OR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register OR. That is,
   * <PRE>
   * [dstDisp] |=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitOR_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "OR", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register OR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] |=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitOR_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "OR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register OR. That is,
   * <PRE>
   * [dstBase + dstDisp] |=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitOR_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "OR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register OR. That is,
   * <PRE>
   * dstReg |=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x09);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "OR", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement OR. That is,
   * <PRE>
   * dstReg |=  (quad)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "OR", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "OR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "OR", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  (quad)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitOR_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "OR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) OR. That is,
   * <PRE>
   * dstReg |=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "OR", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register OR. That is,
   * <PRE>
   * [dstBase] |=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x08);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "OR", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register OR. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] |=  (byte)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitOR_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x08);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "OR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register OR. That is,
   * <PRE>
   * [dstDisp] |=  (byte)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitOR_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x08);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "OR", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register OR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] |=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitOR_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x08);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "OR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register OR. That is,
   * <PRE>
   * [dstBase + dstDisp] |=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitOR_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x08);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "OR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register OR. That is,
   * <PRE>
   * dstReg |=  (byte)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x08);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "OR", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement OR. That is,
   * <PRE>
   * dstReg |=  (byte)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "OR", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  (byte)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "OR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  (byte)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "OR", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset OR. That is,
   * <PRE>
   * dstReg |=  (byte)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitOR_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "OR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) OR. That is,
   * <PRE>
   * dstReg |=  (byte)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x0A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "OR", dstReg, srcBase);
  }

  /**
   * Generate a register--immediate OR. That is,
   * <PRE>
   * dstReg |=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x0D);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "OR", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate OR. That is,
   * <PRE>
   * [dstBase + dstDisp] |=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "OR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate OR. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] |=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "OR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate OR. That is,
   * <PRE>
   * [dstDisp] |=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitOR_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "OR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate OR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] |=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "OR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate OR. That is,
   * <PRE>
   * [dstBase] |=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "OR", dstBase, imm);
  }

  /**
   * Generate a register--immediate OR. That is,
   * <PRE>
   * dstReg |=  (word)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x0D);
      emitImm16(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm16(imm);
    }
    if (lister != null) lister.RI(miStart, "OR", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate OR. That is,
   * <PRE>
   * [dstBase + dstDisp] |=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
      emitImm16(imm);
    }
    if (lister != null) lister.RDI(miStart, "OR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate OR. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] |=  (word)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm16(imm);
    }
    if (lister != null) lister.RFDI(miStart, "OR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate OR. That is,
   * <PRE>
   * [dstDisp] |=  (word)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitOR_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
      emitImm16(imm);
    }
    if (lister != null) lister.RAI(miStart, "OR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate OR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] |=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm16(imm);
    }
    if (lister != null) lister.RXDI(miStart, "OR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate OR. That is,
   * <PRE>
   * [dstBase] |=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
      emitImm16(imm);
    }
    if (lister != null) lister.RNI(miStart, "OR", dstBase, imm);
  }

  /**
   * Generate a register--immediate OR. That is,
   * <PRE>
   * dstReg |=  (quad)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x0D);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "OR", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate OR. That is,
   * <PRE>
   * [dstBase + dstDisp] |=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "OR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate OR. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] |=  (quad)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "OR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate OR. That is,
   * <PRE>
   * [dstDisp] |=  (quad)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitOR_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "OR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate OR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] |=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "OR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate OR. That is,
   * <PRE>
   * [dstBase] |=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x1" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x1" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "OR", dstBase, imm);
  }

  /**
   * Generate a register--immediate OR. That is,
   * <PRE>
   *  dstReg |= (byte) imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x0C);
      emitImm8(imm);
    } else {
      generateREXprefix(false, null, null, dstReg);
      setMachineCodes(mi++, (byte) 0x80);
      // "register 0x1" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm8(imm);
    }
    if (lister != null) lister.RI(miStart, "OR", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate OR. That is,
   * <PRE>
   * [dstBase + dstDisp] |= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x1" is really part of the opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
    emitImm8(imm);
    if (lister != null) lister.RDI(miStart, "OR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate OR. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] |= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitOR_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x1" is really part of the opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    emitImm8(imm);
    if (lister != null) lister.RXDI(miStart, "OR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate OR. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] |= (byte) imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x1" is really part of the opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    emitImm8(imm);
    if (lister != null) lister.RFDI(miStart, "OR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate OR. That is,
   * <PRE>
   * [dstDisp] |= (byte) imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitOR_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x1" is really part of the opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
    emitImm8(imm);
    if (lister != null) lister.RAI(miStart, "OR", dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate OR. That is,
   * <PRE>
   * [dstBase] |= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitOR_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x1" is really part of the opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
    emitImm8(imm);
    if (lister != null) lister.RNI(miStart, "OR", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register SBB. That is,
   * <PRE>
   * [dstBase] -CF=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "SBB", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register SBB. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] -CF=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSBB_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "SBB", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register SBB. That is,
   * <PRE>
   * [dstDisp] -CF=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSBB_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "SBB", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register SBB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -CF=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSBB_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "SBB", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SBB. That is,
   * <PRE>
   * [dstBase + dstDisp] -CF=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSBB_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "SBB", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register SBB. That is,
   * <PRE>
   * dstReg -CF=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "SBB", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SBB. That is,
   * <PRE>
   * dstReg -CF=  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SBB", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SBB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SBB", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSBB_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SBB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) SBB. That is,
   * <PRE>
   * dstReg -CF=  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SBB", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register SBB. That is,
   * <PRE>
   * [dstBase] -CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "SBB", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register SBB. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] -CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSBB_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "SBB", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register SBB. That is,
   * <PRE>
   * [dstDisp] -CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSBB_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "SBB", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register SBB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSBB_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "SBB", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SBB. That is,
   * <PRE>
   * [dstBase + dstDisp] -CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSBB_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "SBB", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register SBB. That is,
   * <PRE>
   * dstReg -CF=  (word)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "SBB", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SBB. That is,
   * <PRE>
   * dstReg -CF=  (word)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SBB", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  (word)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SBB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  (word)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SBB", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  (word)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSBB_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SBB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) SBB. That is,
   * <PRE>
   * dstReg -CF=  (word)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SBB", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register SBB. That is,
   * <PRE>
   * [dstBase] -CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "SBB", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register SBB. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] -CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSBB_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "SBB", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register SBB. That is,
   * <PRE>
   * [dstDisp] -CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSBB_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "SBB", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register SBB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSBB_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "SBB", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SBB. That is,
   * <PRE>
   * [dstBase + dstDisp] -CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSBB_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "SBB", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register SBB. That is,
   * <PRE>
   * dstReg -CF=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x19);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "SBB", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SBB. That is,
   * <PRE>
   * dstReg -CF=  (quad)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SBB", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SBB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SBB", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  (quad)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSBB_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SBB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) SBB. That is,
   * <PRE>
   * dstReg -CF=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SBB", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register SBB. That is,
   * <PRE>
   * [dstBase] -CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x18);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "SBB", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register SBB. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] -CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSBB_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x18);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "SBB", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register SBB. That is,
   * <PRE>
   * [dstDisp] -CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSBB_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x18);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "SBB", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register SBB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSBB_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x18);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "SBB", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SBB. That is,
   * <PRE>
   * [dstBase + dstDisp] -CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSBB_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x18);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "SBB", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register SBB. That is,
   * <PRE>
   * dstReg -CF=  (byte)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x18);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "SBB", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SBB. That is,
   * <PRE>
   * dstReg -CF=  (byte)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SBB", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  (byte)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SBB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  (byte)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SBB", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset SBB. That is,
   * <PRE>
   * dstReg -CF=  (byte)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSBB_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SBB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) SBB. That is,
   * <PRE>
   * dstReg -CF=  (byte)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x1A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SBB", dstReg, srcBase);
  }

  /**
   * Generate a register--immediate SBB. That is,
   * <PRE>
   * dstReg -CF=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x1D);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "SBB", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate SBB. That is,
   * <PRE>
   * [dstBase + dstDisp] -CF=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "SBB", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SBB. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] -CF=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "SBB", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SBB. That is,
   * <PRE>
   * [dstDisp] -CF=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSBB_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "SBB", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SBB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -CF=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "SBB", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate SBB. That is,
   * <PRE>
   * [dstBase] -CF=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "SBB", dstBase, imm);
  }

  /**
   * Generate a register--immediate SBB. That is,
   * <PRE>
   * dstReg -CF=  (word)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x1D);
      emitImm16(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm16(imm);
    }
    if (lister != null) lister.RI(miStart, "SBB", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate SBB. That is,
   * <PRE>
   * [dstBase + dstDisp] -CF=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
      emitImm16(imm);
    }
    if (lister != null) lister.RDI(miStart, "SBB", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SBB. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] -CF=  (word)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm16(imm);
    }
    if (lister != null) lister.RFDI(miStart, "SBB", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SBB. That is,
   * <PRE>
   * [dstDisp] -CF=  (word)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSBB_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
      emitImm16(imm);
    }
    if (lister != null) lister.RAI(miStart, "SBB", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SBB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -CF=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm16(imm);
    }
    if (lister != null) lister.RXDI(miStart, "SBB", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate SBB. That is,
   * <PRE>
   * [dstBase] -CF=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
      emitImm16(imm);
    }
    if (lister != null) lister.RNI(miStart, "SBB", dstBase, imm);
  }

  /**
   * Generate a register--immediate SBB. That is,
   * <PRE>
   * dstReg -CF=  (quad)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x1D);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "SBB", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate SBB. That is,
   * <PRE>
   * [dstBase + dstDisp] -CF=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "SBB", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SBB. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] -CF=  (quad)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "SBB", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SBB. That is,
   * <PRE>
   * [dstDisp] -CF=  (quad)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSBB_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "SBB", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SBB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -CF=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "SBB", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate SBB. That is,
   * <PRE>
   * [dstBase] -CF=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x3" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x3" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "SBB", dstBase, imm);
  }

  /**
   * Generate a register--immediate SBB. That is,
   * <PRE>
   *  dstReg -CF= (byte) imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x1C);
      emitImm8(imm);
    } else {
      generateREXprefix(false, null, null, dstReg);
      setMachineCodes(mi++, (byte) 0x80);
      // "register 0x3" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm8(imm);
    }
    if (lister != null) lister.RI(miStart, "SBB", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate SBB. That is,
   * <PRE>
   * [dstBase + dstDisp] -CF= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x3" is really part of the opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
    emitImm8(imm);
    if (lister != null) lister.RDI(miStart, "SBB", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SBB. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] -CF= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSBB_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x3" is really part of the opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    emitImm8(imm);
    if (lister != null) lister.RXDI(miStart, "SBB", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SBB. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] -CF= (byte) imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x3" is really part of the opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    emitImm8(imm);
    if (lister != null) lister.RFDI(miStart, "SBB", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SBB. That is,
   * <PRE>
   * [dstDisp] -CF= (byte) imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSBB_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x3" is really part of the opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
    emitImm8(imm);
    if (lister != null) lister.RAI(miStart, "SBB", dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate SBB. That is,
   * <PRE>
   * [dstBase] -CF= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSBB_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x3" is really part of the opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
    emitImm8(imm);
    if (lister != null) lister.RNI(miStart, "SBB", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register SUB. That is,
   * <PRE>
   * [dstBase] -=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "SUB", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register SUB. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] -=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSUB_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "SUB", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register SUB. That is,
   * <PRE>
   * [dstDisp] -=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSUB_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "SUB", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register SUB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSUB_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "SUB", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SUB. That is,
   * <PRE>
   * [dstBase + dstDisp] -=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSUB_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "SUB", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register SUB. That is,
   * <PRE>
   * dstReg -=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "SUB", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SUB. That is,
   * <PRE>
   * dstReg -=  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SUB", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SUB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SUB", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSUB_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SUB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) SUB. That is,
   * <PRE>
   * dstReg -=  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SUB", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register SUB. That is,
   * <PRE>
   * [dstBase] -=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "SUB", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register SUB. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] -=  (word)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSUB_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "SUB", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register SUB. That is,
   * <PRE>
   * [dstDisp] -=  (word)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSUB_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "SUB", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register SUB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSUB_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "SUB", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SUB. That is,
   * <PRE>
   * [dstBase + dstDisp] -=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSUB_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "SUB", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register SUB. That is,
   * <PRE>
   * dstReg -=  (word)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "SUB", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SUB. That is,
   * <PRE>
   * dstReg -=  (word)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SUB", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  (word)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SUB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  (word)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SUB", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  (word)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSUB_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SUB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) SUB. That is,
   * <PRE>
   * dstReg -=  (word)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SUB", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register SUB. That is,
   * <PRE>
   * [dstBase] -=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "SUB", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register SUB. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] -=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSUB_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "SUB", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register SUB. That is,
   * <PRE>
   * [dstDisp] -=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSUB_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "SUB", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register SUB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSUB_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "SUB", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SUB. That is,
   * <PRE>
   * [dstBase + dstDisp] -=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSUB_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "SUB", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register SUB. That is,
   * <PRE>
   * dstReg -=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x29);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "SUB", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SUB. That is,
   * <PRE>
   * dstReg -=  (quad)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SUB", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SUB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SUB", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  (quad)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSUB_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SUB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) SUB. That is,
   * <PRE>
   * dstReg -=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SUB", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register SUB. That is,
   * <PRE>
   * [dstBase] -=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x28);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "SUB", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register SUB. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] -=  (byte)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSUB_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x28);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "SUB", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register SUB. That is,
   * <PRE>
   * [dstDisp] -=  (byte)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSUB_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x28);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "SUB", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register SUB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSUB_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x28);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "SUB", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SUB. That is,
   * <PRE>
   * [dstBase + dstDisp] -=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSUB_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x28);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "SUB", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register SUB. That is,
   * <PRE>
   * dstReg -=  (byte)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x28);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "SUB", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SUB. That is,
   * <PRE>
   * dstReg -=  (byte)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SUB", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  (byte)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SUB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  (byte)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SUB", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset SUB. That is,
   * <PRE>
   * dstReg -=  (byte)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSUB_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SUB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) SUB. That is,
   * <PRE>
   * dstReg -=  (byte)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SUB", dstReg, srcBase);
  }

  /**
   * Generate a register--immediate SUB. That is,
   * <PRE>
   * dstReg -=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x2D);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "SUB", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate SUB. That is,
   * <PRE>
   * [dstBase + dstDisp] -=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "SUB", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SUB. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] -=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "SUB", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SUB. That is,
   * <PRE>
   * [dstDisp] -=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSUB_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "SUB", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SUB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "SUB", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate SUB. That is,
   * <PRE>
   * [dstBase] -=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "SUB", dstBase, imm);
  }

  /**
   * Generate a register--immediate SUB. That is,
   * <PRE>
   * dstReg -=  (word)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x2D);
      emitImm16(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm16(imm);
    }
    if (lister != null) lister.RI(miStart, "SUB", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate SUB. That is,
   * <PRE>
   * [dstBase + dstDisp] -=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm16(imm);
    }
    if (lister != null) lister.RDI(miStart, "SUB", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SUB. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] -=  (word)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm16(imm);
    }
    if (lister != null) lister.RFDI(miStart, "SUB", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SUB. That is,
   * <PRE>
   * [dstDisp] -=  (word)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSUB_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm16(imm);
    }
    if (lister != null) lister.RAI(miStart, "SUB", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SUB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm16(imm);
    }
    if (lister != null) lister.RXDI(miStart, "SUB", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate SUB. That is,
   * <PRE>
   * [dstBase] -=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm16(imm);
    }
    if (lister != null) lister.RNI(miStart, "SUB", dstBase, imm);
  }

  /**
   * Generate a register--immediate SUB. That is,
   * <PRE>
   * dstReg -=  (quad)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x2D);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "SUB", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate SUB. That is,
   * <PRE>
   * [dstBase + dstDisp] -=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "SUB", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SUB. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] -=  (quad)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "SUB", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SUB. That is,
   * <PRE>
   * [dstDisp] -=  (quad)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSUB_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "SUB", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SUB. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] -=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "SUB", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate SUB. That is,
   * <PRE>
   * [dstBase] -=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x5" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x5" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "SUB", dstBase, imm);
  }

  /**
   * Generate a register--immediate SUB. That is,
   * <PRE>
   *  dstReg -= (byte) imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x2C);
      emitImm8(imm);
    } else {
      generateREXprefix(false, null, null, dstReg);
      setMachineCodes(mi++, (byte) 0x80);
      // "register 0x5" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm8(imm);
    }
    if (lister != null) lister.RI(miStart, "SUB", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate SUB. That is,
   * <PRE>
   * [dstBase + dstDisp] -= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x5" is really part of the opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
    emitImm8(imm);
    if (lister != null) lister.RDI(miStart, "SUB", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SUB. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] -= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUB_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x5" is really part of the opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    emitImm8(imm);
    if (lister != null) lister.RXDI(miStart, "SUB", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SUB. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] -= (byte) imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x5" is really part of the opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    emitImm8(imm);
    if (lister != null) lister.RFDI(miStart, "SUB", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SUB. That is,
   * <PRE>
   * [dstDisp] -= (byte) imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSUB_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x5" is really part of the opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
    emitImm8(imm);
    if (lister != null) lister.RAI(miStart, "SUB", dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate SUB. That is,
   * <PRE>
   * [dstBase] -= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUB_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x5" is really part of the opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
    emitImm8(imm);
    if (lister != null) lister.RNI(miStart, "SUB", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register TEST. That is,
   * <PRE>
   * [dstBase] &=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "TEST", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register TEST. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] &=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitTEST_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "TEST", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register TEST. That is,
   * <PRE>
   * [dstDisp] &=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitTEST_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "TEST", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register TEST. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitTEST_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "TEST", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register TEST. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitTEST_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "TEST", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register TEST. That is,
   * <PRE>
   * dstReg &=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "TEST", dstReg, srcReg);
  }

  /**
   * Generate a register(indirect)--register TEST. That is,
   * <PRE>
   * [dstBase] &=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "TEST", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register TEST. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] &=  (word)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitTEST_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "TEST", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register TEST. That is,
   * <PRE>
   * [dstDisp] &=  (word)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitTEST_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "TEST", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register TEST. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitTEST_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "TEST", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register TEST. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitTEST_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "TEST", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register TEST. That is,
   * <PRE>
   * dstReg &=  (word)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "TEST", dstReg, srcReg);
  }

  /**
   * Generate a register(indirect)--register TEST. That is,
   * <PRE>
   * [dstBase] &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "TEST", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register TEST. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitTEST_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "TEST", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register TEST. That is,
   * <PRE>
   * [dstDisp] &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitTEST_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "TEST", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register TEST. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitTEST_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "TEST", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register TEST. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitTEST_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "TEST", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register TEST. That is,
   * <PRE>
   * dstReg &=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x85);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "TEST", dstReg, srcReg);
  }

  /**
   * Generate a register(indirect)--register TEST. That is,
   * <PRE>
   * [dstBase] &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x84);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "TEST", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register TEST. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitTEST_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x84);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "TEST", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register TEST. That is,
   * <PRE>
   * [dstDisp] &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitTEST_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x84);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "TEST", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register TEST. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitTEST_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x84);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "TEST", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register TEST. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitTEST_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x84);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "TEST", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register TEST. That is,
   * <PRE>
   * dstReg &=  (byte)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x84);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "TEST", dstReg, srcReg);
  }

  /**
   * Generate a register--immediate TEST. That is,
   * <PRE>
   * dstReg &=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (false) {
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0xA9);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "TEST", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate TEST. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "TEST", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate TEST. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] &=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "TEST", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate TEST. That is,
   * <PRE>
   * [dstDisp] &=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitTEST_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "TEST", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate TEST. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "TEST", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate TEST. That is,
   * <PRE>
   * [dstBase] &=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "TEST", dstBase, imm);
  }

  /**
   * Generate a register--immediate TEST. That is,
   * <PRE>
   * dstReg &=  (word)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (false) {
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0xA9);
      emitImm16(imm);
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RI(miStart, "TEST", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate TEST. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RDI(miStart, "TEST", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate TEST. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] &=  (word)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RFDI(miStart, "TEST", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate TEST. That is,
   * <PRE>
   * [dstDisp] &=  (word)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitTEST_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RAI(miStart, "TEST", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate TEST. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RXDI(miStart, "TEST", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate TEST. That is,
   * <PRE>
   * [dstBase] &=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm16(imm);
    }
    if (lister != null) lister.RNI(miStart, "TEST", dstBase, imm);
  }

  /**
   * Generate a register--immediate TEST. That is,
   * <PRE>
   * dstReg &=  (quad)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstReg);
    // single byte opcode
    if (false) {
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0xA9);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "TEST", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate TEST. That is,
   * <PRE>
   * [dstBase + dstDisp] &=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "TEST", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate TEST. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] &=  (quad)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, null);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "TEST", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate TEST. That is,
   * <PRE>
   * [dstDisp] &=  (quad)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitTEST_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "TEST", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate TEST. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] &=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, dstBase);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "TEST", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate TEST. That is,
   * <PRE>
   * [dstBase] &=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (false) {
    } else {
      setMachineCodes(mi++, (byte) 0xF7);
      // "register 0x0" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "TEST", dstBase, imm);
  }

  /**
   * Generate a register--immediate TEST. That is,
   * <PRE>
   *  dstReg &= (byte) imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0xA8);
      emitImm8(imm);
    } else {
      generateREXprefix(false, null, null, dstReg);
      setMachineCodes(mi++, (byte) 0xF6);
      // "register 0x0" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm8(imm);
    }
    if (lister != null) lister.RI(miStart, "TEST", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate TEST. That is,
   * <PRE>
   * [dstBase + dstDisp] &= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x0" is really part of the opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RDI(miStart, "TEST", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate TEST. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] &= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitTEST_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x0" is really part of the opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RXDI(miStart, "TEST", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate TEST. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] &= (byte) imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x0" is really part of the opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RFDI(miStart, "TEST", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate TEST. That is,
   * <PRE>
   * [dstDisp] &= (byte) imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitTEST_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x0" is really part of the opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RAI(miStart, "TEST", dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate TEST. That is,
   * <PRE>
   * [dstBase] &= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitTEST_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x0" is really part of the opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RNI(miStart, "TEST", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register XOR. That is,
   * <PRE>
   * [dstBase] ~=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "XOR", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register XOR. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] ~=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitXOR_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "XOR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register XOR. That is,
   * <PRE>
   * [dstDisp] ~=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitXOR_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "XOR", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register XOR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ~=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitXOR_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "XOR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register XOR. That is,
   * <PRE>
   * [dstBase + dstDisp] ~=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitXOR_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "XOR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register XOR. That is,
   * <PRE>
   * dstReg ~=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "XOR", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement XOR. That is,
   * <PRE>
   * dstReg ~=  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "XOR", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "XOR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "XOR", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitXOR_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "XOR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) XOR. That is,
   * <PRE>
   * dstReg ~=  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "XOR", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register XOR. That is,
   * <PRE>
   * [dstBase] ~=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "XOR", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register XOR. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] ~=  (word)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitXOR_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "XOR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register XOR. That is,
   * <PRE>
   * [dstDisp] ~=  (word)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitXOR_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "XOR", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register XOR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ~=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitXOR_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "XOR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register XOR. That is,
   * <PRE>
   * [dstBase + dstDisp] ~=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitXOR_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "XOR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register XOR. That is,
   * <PRE>
   * dstReg ~=  (word)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "XOR", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement XOR. That is,
   * <PRE>
   * dstReg ~=  (word)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "XOR", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  (word)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "XOR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  (word)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "XOR", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  (word)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitXOR_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "XOR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) XOR. That is,
   * <PRE>
   * dstReg ~=  (word)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "XOR", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register XOR. That is,
   * <PRE>
   * [dstBase] ~=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "XOR", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register XOR. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] ~=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitXOR_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "XOR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register XOR. That is,
   * <PRE>
   * [dstDisp] ~=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitXOR_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "XOR", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register XOR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ~=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitXOR_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "XOR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register XOR. That is,
   * <PRE>
   * [dstBase + dstDisp] ~=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitXOR_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "XOR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register XOR. That is,
   * <PRE>
   * dstReg ~=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x31);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "XOR", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement XOR. That is,
   * <PRE>
   * dstReg ~=  (quad)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "XOR", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "XOR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "XOR", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  (quad)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitXOR_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "XOR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) XOR. That is,
   * <PRE>
   * dstReg ~=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x33);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "XOR", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register XOR. That is,
   * <PRE>
   * [dstBase] ~=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x30);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "XOR", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register XOR. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] ~=  (byte)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitXOR_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x30);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "XOR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register XOR. That is,
   * <PRE>
   * [dstDisp] ~=  (byte)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitXOR_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x30);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "XOR", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register XOR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ~=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitXOR_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x30);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "XOR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register XOR. That is,
   * <PRE>
   * [dstBase + dstDisp] ~=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitXOR_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x30);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "XOR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register XOR. That is,
   * <PRE>
   * dstReg ~=  (byte)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x30);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "XOR", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement XOR. That is,
   * <PRE>
   * dstReg ~=  (byte)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x32);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "XOR", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  (byte)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x32);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "XOR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  (byte)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x32);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "XOR", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset XOR. That is,
   * <PRE>
   * dstReg ~=  (byte)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitXOR_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x32);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "XOR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) XOR. That is,
   * <PRE>
   * dstReg ~=  (byte)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x32);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "XOR", dstReg, srcBase);
  }

  /**
   * Generate a register--immediate XOR. That is,
   * <PRE>
   * dstReg ~=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x35);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "XOR", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate XOR. That is,
   * <PRE>
   * [dstBase + dstDisp] ~=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "XOR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate XOR. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] ~=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "XOR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate XOR. That is,
   * <PRE>
   * [dstDisp] ~=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitXOR_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "XOR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate XOR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ~=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "XOR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate XOR. That is,
   * <PRE>
   * [dstBase] ~=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "XOR", dstBase, imm);
  }

  /**
   * Generate a register--immediate XOR. That is,
   * <PRE>
   * dstReg ~=  (word)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x35);
      emitImm16(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x6));
      emitImm16(imm);
    }
    if (lister != null) lister.RI(miStart, "XOR", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate XOR. That is,
   * <PRE>
   * [dstBase + dstDisp] ~=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x6));
      emitImm16(imm);
    }
    if (lister != null) lister.RDI(miStart, "XOR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate XOR. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] ~=  (word)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm16(imm);
    }
    if (lister != null) lister.RFDI(miStart, "XOR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate XOR. That is,
   * <PRE>
   * [dstDisp] ~=  (word)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitXOR_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x6));
      emitImm16(imm);
    }
    if (lister != null) lister.RAI(miStart, "XOR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate XOR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ~=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm16(imm);
    }
    if (lister != null) lister.RXDI(miStart, "XOR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate XOR. That is,
   * <PRE>
   * [dstBase] ~=  (word)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x6));
      emitImm16(imm);
    }
    if (lister != null) lister.RNI(miStart, "XOR", dstBase, imm);
  }

  /**
   * Generate a register--immediate XOR. That is,
   * <PRE>
   * dstReg ~=  (quad)  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstReg);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x35);
      emitImm32(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RI(miStart, "XOR", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate XOR. That is,
   * <PRE>
   * [dstBase + dstDisp] ~=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RDI(miStart, "XOR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate XOR. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] ~=  (quad)  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RFDI(miStart, "XOR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate XOR. That is,
   * <PRE>
   * [dstDisp] ~=  (quad)  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitXOR_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RAI(miStart, "XOR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate XOR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] ~=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, dstIndex, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RXDI(miStart, "XOR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate XOR. That is,
   * <PRE>
   * [dstBase] ~=  (quad)  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, dstBase);
    // single byte opcode
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0x83);
      // "register 0x6" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      setMachineCodes(mi++, (byte) 0x81);
      // "register 0x6" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x6));
      emitImm32(imm);
    }
    if (lister != null) lister.RNI(miStart, "XOR", dstBase, imm);
  }

  /**
   * Generate a register--immediate XOR. That is,
   * <PRE>
   *  dstReg ~= (byte) imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (dstReg == EAX) {
      setMachineCodes(mi++, (byte) 0x34);
      emitImm8(imm);
    } else {
      generateREXprefix(false, null, null, dstReg);
      setMachineCodes(mi++, (byte) 0x80);
      // "register 0x6" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x6));
      emitImm8(imm);
    }
    if (lister != null) lister.RI(miStart, "XOR", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate XOR. That is,
   * <PRE>
   * [dstBase + dstDisp] ~= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x6" is really part of the opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x6));
    emitImm8(imm);
    if (lister != null) lister.RDI(miStart, "XOR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate XOR. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] ~= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXOR_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x6" is really part of the opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
    emitImm8(imm);
    if (lister != null) lister.RXDI(miStart, "XOR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate XOR. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] ~= (byte) imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x6" is really part of the opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
    emitImm8(imm);
    if (lister != null) lister.RFDI(miStart, "XOR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate XOR. That is,
   * <PRE>
   * [dstDisp] ~= (byte) imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitXOR_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x6" is really part of the opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x6));
    emitImm8(imm);
    if (lister != null) lister.RAI(miStart, "XOR", dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate XOR. That is,
   * <PRE>
   * [dstBase] ~= (byte) imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXOR_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x80);
    // "register 0x6" is really part of the opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x6));
    emitImm8(imm);
    if (lister != null) lister.RNI(miStart, "XOR", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register BT. That is,
   * <PRE>
   * [dstBase] BT=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBT_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA3);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "BT", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register BT. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] BT=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitBT_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "BT", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register BT. That is,
   * <PRE>
   * [dstDisp] BT=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitBT_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA3);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "BT", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register BT. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] BT=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitBT_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "BT", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register BT. That is,
   * <PRE>
   * [dstBase + dstDisp] BT=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitBT_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA3);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "BT", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register BT. That is,
   * <PRE>
   * dstReg BT=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBT_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA3);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "BT", dstReg, srcReg);
  }

  /**
   * Generate a register--immediate BT. That is,
   * <PRE>
   * dstReg BT=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBT_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x4" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BT instruction");
    }
    if (lister != null) lister.RI(miStart, "BT", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate BT. That is,
   * <PRE>
   * [dstBase + dstDisp] BT=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBT_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x4" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BT instruction");
    }
    if (lister != null) lister.RDI(miStart, "BT", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate BT. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] BT=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBT_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x4" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BT instruction");
    }
    if (lister != null) lister.RFDI(miStart, "BT", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate BT. That is,
   * <PRE>
   * [dstDisp] BT=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitBT_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x4" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BT instruction");
    }
    if (lister != null) lister.RAI(miStart, "BT", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate BT. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] BT=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBT_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x4" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BT instruction");
    }
    if (lister != null) lister.RXDI(miStart, "BT", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate BT. That is,
   * <PRE>
   * [dstBase] BT=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBT_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x4" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BT instruction");
    }
    if (lister != null) lister.RNI(miStart, "BT", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register BTC. That is,
   * <PRE>
   * [dstBase] BTC=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBTC_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBB);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "BTC", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register BTC. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] BTC=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitBTC_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBB);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "BTC", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register BTC. That is,
   * <PRE>
   * [dstDisp] BTC=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitBTC_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBB);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "BTC", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register BTC. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] BTC=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitBTC_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBB);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "BTC", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register BTC. That is,
   * <PRE>
   * [dstBase + dstDisp] BTC=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitBTC_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBB);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "BTC", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register BTC. That is,
   * <PRE>
   * dstReg BTC=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBTC_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBB);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "BTC", dstReg, srcReg);
  }

  /**
   * Generate a register--immediate BTC. That is,
   * <PRE>
   * dstReg BTC=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTC_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x7" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTC instruction");
    }
    if (lister != null) lister.RI(miStart, "BTC", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate BTC. That is,
   * <PRE>
   * [dstBase + dstDisp] BTC=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTC_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x7" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTC instruction");
    }
    if (lister != null) lister.RDI(miStart, "BTC", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate BTC. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] BTC=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTC_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x7" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTC instruction");
    }
    if (lister != null) lister.RFDI(miStart, "BTC", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate BTC. That is,
   * <PRE>
   * [dstDisp] BTC=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitBTC_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x7" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTC instruction");
    }
    if (lister != null) lister.RAI(miStart, "BTC", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate BTC. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] BTC=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBTC_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x7" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTC instruction");
    }
    if (lister != null) lister.RXDI(miStart, "BTC", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate BTC. That is,
   * <PRE>
   * [dstBase] BTC=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTC_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x7" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTC instruction");
    }
    if (lister != null) lister.RNI(miStart, "BTC", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register BTR. That is,
   * <PRE>
   * [dstBase] BTR=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBTR_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB3);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "BTR", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register BTR. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] BTR=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitBTR_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "BTR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register BTR. That is,
   * <PRE>
   * [dstDisp] BTR=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitBTR_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB3);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "BTR", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register BTR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] BTR=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitBTR_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "BTR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register BTR. That is,
   * <PRE>
   * [dstBase + dstDisp] BTR=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitBTR_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB3);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "BTR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register BTR. That is,
   * <PRE>
   * dstReg BTR=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBTR_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB3);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "BTR", dstReg, srcReg);
  }

  /**
   * Generate a register--immediate BTR. That is,
   * <PRE>
   * dstReg BTR=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTR_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x6" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTR instruction");
    }
    if (lister != null) lister.RI(miStart, "BTR", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate BTR. That is,
   * <PRE>
   * [dstBase + dstDisp] BTR=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTR_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x6" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTR instruction");
    }
    if (lister != null) lister.RDI(miStart, "BTR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate BTR. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] BTR=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTR_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x6" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTR instruction");
    }
    if (lister != null) lister.RFDI(miStart, "BTR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate BTR. That is,
   * <PRE>
   * [dstDisp] BTR=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitBTR_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x6" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTR instruction");
    }
    if (lister != null) lister.RAI(miStart, "BTR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate BTR. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] BTR=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBTR_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x6" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTR instruction");
    }
    if (lister != null) lister.RXDI(miStart, "BTR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate BTR. That is,
   * <PRE>
   * [dstBase] BTR=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTR_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x6" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x6));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTR instruction");
    }
    if (lister != null) lister.RNI(miStart, "BTR", dstBase, imm);
  }

  /**
   * Generate a register(indirect)--register BTS. That is,
   * <PRE>
   * [dstBase] BTS=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBTS_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAB);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "BTS", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register BTS. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] BTS=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitBTS_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAB);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "BTS", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register BTS. That is,
   * <PRE>
   * [dstDisp] BTS=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitBTS_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAB);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "BTS", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register BTS. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] BTS=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitBTS_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAB);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "BTS", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register BTS. That is,
   * <PRE>
   * [dstBase + dstDisp] BTS=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitBTS_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAB);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "BTS", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register BTS. That is,
   * <PRE>
   * dstReg BTS=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBTS_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAB);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "BTS", dstReg, srcReg);
  }

  /**
   * Generate a register--immediate BTS. That is,
   * <PRE>
   * dstReg BTS=  imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTS_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x5" is really part of the opcode
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTS instruction");
    }
    if (lister != null) lister.RI(miStart, "BTS", dstReg, imm);
  }

  /**
   * Generate a register-displacement--immediate BTS. That is,
   * <PRE>
   * [dstBase + dstDisp] BTS=  imm
   * </PRE>
   *
   * @param dstBase the destination register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTS_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x5" is really part of the opcode
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTS instruction");
    }
    if (lister != null) lister.RDI(miStart, "BTS", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate BTS. That is,
   * <PRE>
   * [dstIndex<<dstScale + dstDisp] BTS=  imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTS_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x5" is really part of the opcode
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTS instruction");
    }
    if (lister != null) lister.RFDI(miStart, "BTS", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate BTS. That is,
   * <PRE>
   * [dstDisp] BTS=  imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitBTS_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x5" is really part of the opcode
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTS instruction");
    }
    if (lister != null) lister.RAI(miStart, "BTS", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate BTS. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] BTS=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitBTS_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x5" is really part of the opcode
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTS instruction");
    }
    if (lister != null) lister.RXDI(miStart, "BTS", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register(indirect)--immediate BTS. That is,
   * <PRE>
   * [dstBase] BTS=  imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitBTS_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    if (fits(imm,8)) {
      setMachineCodes(mi++, (byte) 0xBA);
      // "register 0x5" is really part of the opcode
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    } else {
      throw new InternalError("Data too large for BTS instruction");
    }
    if (lister != null) lister.RNI(miStart, "BTS", dstBase, imm);
  }

  /**
   * Generate a CALL to a label or immediate. That is,
   * <PRE>
   *  pc = {future address from label | imm}
   * </PRE>
   *
   * @param imm offset to immediate CALL to. 0 means use
   * label. Immediate is assumed to be within current instructions.
   * @param label label to branch to (used when imm == 0)
   */
  public final void emitCALL_ImmOrLabel(int imm, int label) {
    if (imm == 0)
      emitCALL_Label(label);
    else
      emitCALL_Imm(imm);
  }

  /**
   * Branch to the given target with a CALL instruction
   * <PRE>
   * IP = (instruction @ label)
   * </PRE>
   *
   * This emit method is expecting only a forward branch (that is
   * what the Label operand means); it creates a ForwardReference
   * to the given label, and puts it into the assembler's list of
   * references to resolve.  This emitter knows the branch is
   * unconditional, so it uses
   * {@link org.jikesrvm.compilers.common.assembler.ForwardReference.UnconditionalBranch}
   * as the forward reference type to create.
   *
   * All forward branches have a label as the branch target; clients
   * can arbirarily associate labels and instructions, but must be
   * consistent in giving the chosen label as the target of branches
   * to an instruction and calling resolveForwardBranches with the
   * given label immediately before emitting the target instruction.
   * See the header comments of ForwardReference for more details.
   *
   * @param label the label associated with the branch target instrucion
   */
  public final void emitCALL_Label(int label) {
      int miStart = mi;
      ForwardReference r =
        new ForwardReference.UnconditionalBranch(mi, label);
      forwardRefs = ForwardReference.enqueue(forwardRefs, r);
      setMachineCodes(mi++, (byte) 0xE8);
      mi += 4; // leave space for displacement
      if (lister != null) lister.I(miStart, "CALL", label);
  }

  /**
   * Generate a CALL to immediate. That is,
   * <PRE>
   * pc = imm
   * </PRE>
   *
   * @param imm offset to immediate CALL to (within current instructions)
   */
  public final void emitCALL_Imm(int imm) {
    int miStart = mi;
       setMachineCodes(mi++, (byte) 0xE8);
       // offset of next instruction (this instruction is 5 bytes,
       // but we just accounted for one of them in the mi++ above)
       emitImm32(imm - (mi + 4));
    if (lister != null) lister.I(miStart, "CALL", imm);
  }

  /**
   * Generate a CALL to register. That is,
   * <PRE>
   * pc = dstReg
   * </PRE>
   *
   * @param dstReg register containing destination address
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCALL_Reg(GPR dstReg) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x2" is really part of the CALL opcode
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
    if (lister != null) lister.R(miStart, "CALL", dstReg);
  }

  /**
   * Generate a CALL to register and displacement. That is,
   * <PRE>
   * pc = [dstBase + dstDisp]
   * </PRE>
   *
   * @param dstBase the destination base address register
   * @param dstDisp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCALL_RegDisp(GPR dstBase, Offset dstDisp) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x2" is really part of the CALL opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RD(miStart, "CALL", dstBase, dstDisp);
  }

  /**
   * Generate a CALL to register indirect. That is,
   * <PRE>
   * pc = [dstBase]
   * </PRE>
   *
   * @param dstBase the destination base address register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCALL_RegInd(GPR dstBase) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x2" is really part of the CALL opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
    if (lister != null) lister.RN(miStart, "CALL", dstBase);
  }

  /**
   * Generate a CALL to register offset. That is,
   * <PRE>
   * pc = [dstIndex<<dstScale + dstDisp]
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCALL_RegOff(GPR dstIndex, short dstScale, Offset dstDisp) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x2" is really part of the CALL opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RFD(miStart, "CALL", dstIndex, dstScale, dstDisp);
  }

  /**
   * Generate a CALL to absolute address. That is,
   * <PRE>
   * pc = [dstDisp]
   * </PRE>
   *
   * @param dstDisp the destination displacement
   */
  public final void emitCALL_Abs(Address dstDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x2" is really part of the CALL opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RA(miStart, "CALL", dstDisp);
  }

  /**
   * Generate a CALL to register offset. That is,
   * <PRE>
   * pc = [dstBase + dstIndex<<dstScale + dstDisp]
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCALL_RegIdx(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x2" is really part of the CALL opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RXD(miStart, "CALL", dstBase, dstIndex, dstScale, dstDisp);
  }

  /**
   * Generate a JMP to a label or immediate. That is,
   * <PRE>
   *  pc = {future address from label | imm}
   * </PRE>
   *
   * @param imm offset to immediate JMP to. 0 means use
   * label. Immediate is assumed to be within current instructions.
   * @param label label to branch to (used when imm == 0)
   */
  public final void emitJMP_ImmOrLabel(int imm, int label) {
    if (imm == 0)
      emitJMP_Label(label);
    else
      emitJMP_Imm(imm);
  }

  /**
   * Branch to the given target with a JMP instruction
   * <PRE>
   * IP = (instruction @ label)
   * </PRE>
   *
   * This emit method is expecting only a forward branch (that is
   * what the Label operand means); it creates a ForwardReference
   * to the given label, and puts it into the assembler's list of
   * references to resolve.  This emitter knows the branch is
   * unconditional, so it uses
   * {@link org.jikesrvm.compilers.common.assembler.ForwardReference.UnconditionalBranch}
   * as the forward reference type to create.
   *
   * All forward branches have a label as the branch target; clients
   * can arbirarily associate labels and instructions, but must be
   * consistent in giving the chosen label as the target of branches
   * to an instruction and calling resolveForwardBranches with the
   * given label immediately before emitting the target instruction.
   * See the header comments of ForwardReference for more details.
   *
   * @param label the label associated with the branch target instrucion
   */
  public final void emitJMP_Label(int label) {
      int miStart = mi;
      ForwardReference r =
        new ForwardReference.UnconditionalBranch(mi, label);
      forwardRefs = ForwardReference.enqueue(forwardRefs, r);
      setMachineCodes(mi++, (byte) 0xE9);
      mi += 4; // leave space for displacement
      if (lister != null) lister.I(miStart, "JMP", label);
  }

  /**
   * Generate a JMP to immediate. That is,
   * <PRE>
   * pc = imm
   * </PRE>
   *
   * @param imm offset to immediate JMP to (within current instructions)
   */
  public final void emitJMP_Imm(int imm) {
    int miStart = mi;
    // can we fit the offset from the next instruction into 8
    // bits, assuming this instruction is 2 bytes (which it will
    // be if the offset fits into 8 bits)?
    int relOffset = imm - (mi + 2);
    if (fits(relOffset,8)) {
      // yes, so use short form.
      setMachineCodes(mi++, (byte) 0xEB);
      emitImm8((byte) relOffset);
    } else {
       // no, must use 32 bit offset and ignore relOffset to
       // account for the fact that this instruction now has to
       // be 5 bytes long.
       setMachineCodes(mi++, (byte) 0xE9);
       // offset of next instruction (this instruction is 5 bytes,
       // but we just accounted for one of them in the mi++ above)
       emitImm32(imm - (mi + 4));
    }
    if (lister != null) lister.I(miStart, "JMP", imm);
  }

  /**
   * Generate a JMP to register. That is,
   * <PRE>
   * pc = dstReg
   * </PRE>
   *
   * @param dstReg register containing destination address
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitJMP_Reg(GPR dstReg) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x4" is really part of the JMP opcode
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.R(miStart, "JMP", dstReg);
  }

  /**
   * Generate a JMP to register and displacement. That is,
   * <PRE>
   * pc = [dstBase + dstDisp]
   * </PRE>
   *
   * @param dstBase the destination base address register
   * @param dstDisp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitJMP_RegDisp(GPR dstBase, Offset dstDisp) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x4" is really part of the JMP opcode
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RD(miStart, "JMP", dstBase, dstDisp);
  }

  /**
   * Generate a JMP to register indirect. That is,
   * <PRE>
   * pc = [dstBase]
   * </PRE>
   *
   * @param dstBase the destination base address register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitJMP_RegInd(GPR dstBase) {
    int miStart = mi;
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x4" is really part of the JMP opcode
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RN(miStart, "JMP", dstBase);
  }

  /**
   * Generate a JMP to register offset. That is,
   * <PRE>
   * pc = [dstIndex<<dstScale + dstDisp]
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitJMP_RegOff(GPR dstIndex, short dstScale, Offset dstDisp) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x4" is really part of the JMP opcode
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RFD(miStart, "JMP", dstIndex, dstScale, dstDisp);
  }

  /**
   * Generate a JMP to absolute address. That is,
   * <PRE>
   * pc = [dstDisp]
   * </PRE>
   *
   * @param dstDisp the destination displacement
   */
  public final void emitJMP_Abs(Address dstDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x4" is really part of the JMP opcode
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RA(miStart, "JMP", dstDisp);
  }

  /**
   * Generate a JMP to register offset. That is,
   * <PRE>
   * pc = [dstBase + dstIndex<<dstScale + dstDisp]
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitJMP_RegIdx(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp) {
    int miStart = mi;
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x4" is really part of the JMP opcode
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RXD(miStart, "JMP", dstBase, dstIndex, dstScale, dstDisp);
  }

  /**
   * Generate a DEC on a register. That is,
   * <PRE>
   * --  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public void emitDEC_Reg(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, reg);
    if (!VM.buildFor32Addr()) {
      setMachineCodes(mi++, (byte) (0xFF));
      emitRegRegOperands(reg, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) (0x48 | (reg.value() & 7)));
    }
    if (lister != null) lister.R(miStart, "DEC", reg);
  }
  /**
   * Generate a DEC to register-displacement offset. That is,
   * <PRE>
   * --  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegDisp(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RD(miStart, "DEC", base, disp);
  }

  /**
   * Generate a DEC to register indirect. That is,
   * <PRE>
   * --  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegInd(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x1));
    if (lister != null) lister.RN(miStart, "DEC", base);
  }

  /**
   * Generate a DEC to register offset. That is,
   * <PRE>
   * --  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegOff(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RFD(miStart, "DEC", index, scale, disp);
  }

  /**
   * Generate a DEC to absolute address. That is,
   * <PRE>
   * --  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitDEC_Abs(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RA(miStart, "DEC", disp);
  }

  /**
   * Generate a DEC to register offset. That is,
   * <PRE>
   * --  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDEC_RegIdx(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RXD(miStart, "DEC", base, index, scale, disp);
  }

  /**
   * Generate a DEC on a register. That is,
   * <PRE>
   * --  (byte)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_Reg_Byte(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) 0xFE);
    emitRegRegOperands(reg, GPR.getForOpcode(0x1));
    if (lister != null) lister.R(miStart, "DEC", reg);
  }
  /**
   * Generate a DEC to register-displacement offset. That is,
   * <PRE>
   * --  (byte)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegDisp_Byte(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFE);
    // "register 0x1" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RD(miStart, "DEC", base, disp);
  }

  /**
   * Generate a DEC to register indirect. That is,
   * <PRE>
   * --  (byte)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegInd_Byte(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFE);
    // "register 0x1" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x1));
    if (lister != null) lister.RN(miStart, "DEC", base);
  }

  /**
   * Generate a DEC to register offset. That is,
   * <PRE>
   * --  (byte)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegOff_Byte(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xFE);
    // "register 0x1" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RFD(miStart, "DEC", index, scale, disp);
  }

  /**
   * Generate a DEC to absolute address. That is,
   * <PRE>
   * --  (byte)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitDEC_Abs_Byte(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xFE);
    // "register 0x1" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RA(miStart, "DEC", disp);
  }

  /**
   * Generate a DEC to register offset. That is,
   * <PRE>
   * --  (byte)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDEC_RegIdx_Byte(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xFE);
    // "register 0x1" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RXD(miStart, "DEC", base, index, scale, disp);
  }

  /**
   * Generate a DEC on a register. That is,
   * <PRE>
   * --  (word)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public void emitDEC_Reg_Word(GPR reg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, reg);
    if (!VM.buildFor32Addr()) {
      setMachineCodes(mi++, (byte) (0xFF));
      emitRegRegOperands(reg, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) (0x48 | (reg.value() & 7)));
    }
    if (lister != null) lister.R(miStart, "DEC", reg);
  }
  /**
   * Generate a DEC to register-displacement offset. That is,
   * <PRE>
   * --  (word)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegDisp_Word(GPR base, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RD(miStart, "DEC", base, disp);
  }

  /**
   * Generate a DEC to register indirect. That is,
   * <PRE>
   * --  (word)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegInd_Word(GPR base) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x1));
    if (lister != null) lister.RN(miStart, "DEC", base);
  }

  /**
   * Generate a DEC to register offset. That is,
   * <PRE>
   * --  (word)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegOff_Word(GPR index, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RFD(miStart, "DEC", index, scale, disp);
  }

  /**
   * Generate a DEC to absolute address. That is,
   * <PRE>
   * --  (word)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitDEC_Abs_Word(Address disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RA(miStart, "DEC", disp);
  }

  /**
   * Generate a DEC to register offset. That is,
   * <PRE>
   * --  (word)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDEC_RegIdx_Word(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RXD(miStart, "DEC", base, index, scale, disp);
  }

  /**
   * Generate a DEC on a register. That is,
   * <PRE>
   * --  (quad)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public void emitDEC_Reg_Quad(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, reg);
    if (!VM.buildFor32Addr()) {
      setMachineCodes(mi++, (byte) (0xFF));
      emitRegRegOperands(reg, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) (0x48 | (reg.value() & 7)));
    }
    if (lister != null) lister.R(miStart, "DEC", reg);
  }
  /**
   * Generate a DEC to register-displacement offset. That is,
   * <PRE>
   * --  (quad)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegDisp_Quad(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RD(miStart, "DEC", base, disp);
  }

  /**
   * Generate a DEC to register indirect. That is,
   * <PRE>
   * --  (quad)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegInd_Quad(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x1));
    if (lister != null) lister.RN(miStart, "DEC", base);
  }

  /**
   * Generate a DEC to register offset. That is,
   * <PRE>
   * --  (quad)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDEC_RegOff_Quad(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, index, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RFD(miStart, "DEC", index, scale, disp);
  }

  /**
   * Generate a DEC to absolute address. That is,
   * <PRE>
   * --  (quad)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitDEC_Abs_Quad(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RA(miStart, "DEC", disp);
  }

  /**
   * Generate a DEC to register offset. That is,
   * <PRE>
   * --  (quad)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDEC_RegIdx_Quad(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, index, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x1" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RXD(miStart, "DEC", base, index, scale, disp);
  }

  /**
   * Generate a INC on a register. That is,
   * <PRE>
   * ++  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public void emitINC_Reg(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, reg);
    if (!VM.buildFor32Addr()) {
      setMachineCodes(mi++, (byte) (0xFF));
      emitRegRegOperands(reg, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) (0x40 | (reg.value() & 7)));
    }
    if (lister != null) lister.R(miStart, "INC", reg);
  }
  /**
   * Generate a INC to register-displacement offset. That is,
   * <PRE>
   * ++  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegDisp(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RD(miStart, "INC", base, disp);
  }

  /**
   * Generate a INC to register indirect. That is,
   * <PRE>
   * ++  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegInd(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x0));
    if (lister != null) lister.RN(miStart, "INC", base);
  }

  /**
   * Generate a INC to register offset. That is,
   * <PRE>
   * ++  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegOff(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RFD(miStart, "INC", index, scale, disp);
  }

  /**
   * Generate a INC to absolute address. That is,
   * <PRE>
   * ++  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitINC_Abs(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RA(miStart, "INC", disp);
  }

  /**
   * Generate a INC to register offset. That is,
   * <PRE>
   * ++  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitINC_RegIdx(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RXD(miStart, "INC", base, index, scale, disp);
  }

  /**
   * Generate a INC on a register. That is,
   * <PRE>
   * ++  (byte)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_Reg_Byte(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) 0xFE);
    emitRegRegOperands(reg, GPR.getForOpcode(0x0));
    if (lister != null) lister.R(miStart, "INC", reg);
  }
  /**
   * Generate a INC to register-displacement offset. That is,
   * <PRE>
   * ++  (byte)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegDisp_Byte(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFE);
    // "register 0x0" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RD(miStart, "INC", base, disp);
  }

  /**
   * Generate a INC to register indirect. That is,
   * <PRE>
   * ++  (byte)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegInd_Byte(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFE);
    // "register 0x0" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x0));
    if (lister != null) lister.RN(miStart, "INC", base);
  }

  /**
   * Generate a INC to register offset. That is,
   * <PRE>
   * ++  (byte)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegOff_Byte(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xFE);
    // "register 0x0" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RFD(miStart, "INC", index, scale, disp);
  }

  /**
   * Generate a INC to absolute address. That is,
   * <PRE>
   * ++  (byte)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitINC_Abs_Byte(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xFE);
    // "register 0x0" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RA(miStart, "INC", disp);
  }

  /**
   * Generate a INC to register offset. That is,
   * <PRE>
   * ++  (byte)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitINC_RegIdx_Byte(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xFE);
    // "register 0x0" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RXD(miStart, "INC", base, index, scale, disp);
  }

  /**
   * Generate a INC on a register. That is,
   * <PRE>
   * ++  (word)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public void emitINC_Reg_Word(GPR reg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, reg);
    if (!VM.buildFor32Addr()) {
      setMachineCodes(mi++, (byte) (0xFF));
      emitRegRegOperands(reg, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) (0x40 | (reg.value() & 7)));
    }
    if (lister != null) lister.R(miStart, "INC", reg);
  }
  /**
   * Generate a INC to register-displacement offset. That is,
   * <PRE>
   * ++  (word)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegDisp_Word(GPR base, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RD(miStart, "INC", base, disp);
  }

  /**
   * Generate a INC to register indirect. That is,
   * <PRE>
   * ++  (word)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegInd_Word(GPR base) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x0));
    if (lister != null) lister.RN(miStart, "INC", base);
  }

  /**
   * Generate a INC to register offset. That is,
   * <PRE>
   * ++  (word)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegOff_Word(GPR index, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RFD(miStart, "INC", index, scale, disp);
  }

  /**
   * Generate a INC to absolute address. That is,
   * <PRE>
   * ++  (word)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitINC_Abs_Word(Address disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RA(miStart, "INC", disp);
  }

  /**
   * Generate a INC to register offset. That is,
   * <PRE>
   * ++  (word)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitINC_RegIdx_Word(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RXD(miStart, "INC", base, index, scale, disp);
  }

  /**
   * Generate a INC on a register. That is,
   * <PRE>
   * ++  (quad)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public void emitINC_Reg_Quad(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, reg);
    if (!VM.buildFor32Addr()) {
      setMachineCodes(mi++, (byte) (0xFF));
      emitRegRegOperands(reg, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) (0x40 | (reg.value() & 7)));
    }
    if (lister != null) lister.R(miStart, "INC", reg);
  }
  /**
   * Generate a INC to register-displacement offset. That is,
   * <PRE>
   * ++  (quad)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegDisp_Quad(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RD(miStart, "INC", base, disp);
  }

  /**
   * Generate a INC to register indirect. That is,
   * <PRE>
   * ++  (quad)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegInd_Quad(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x0));
    if (lister != null) lister.RN(miStart, "INC", base);
  }

  /**
   * Generate a INC to register offset. That is,
   * <PRE>
   * ++  (quad)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitINC_RegOff_Quad(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, index, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RFD(miStart, "INC", index, scale, disp);
  }

  /**
   * Generate a INC to absolute address. That is,
   * <PRE>
   * ++  (quad)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitINC_Abs_Quad(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RA(miStart, "INC", disp);
  }

  /**
   * Generate a INC to register offset. That is,
   * <PRE>
   * ++  (quad)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitINC_RegIdx_Quad(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, index, base);
    setMachineCodes(mi++, (byte) 0xFF);
    // "register 0x0" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RXD(miStart, "INC", base, index, scale, disp);
  }

  /**
   * Generate a NEG on a register. That is,
   * <PRE>
   * -  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_Reg(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(reg, GPR.getForOpcode(0x3));
    if (lister != null) lister.R(miStart, "NEG", reg);
  }
  /**
   * Generate a NEG to register-displacement offset. That is,
   * <PRE>
   * -  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegDisp(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RD(miStart, "NEG", base, disp);
  }

  /**
   * Generate a NEG to register indirect. That is,
   * <PRE>
   * -  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegInd(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x3));
    if (lister != null) lister.RN(miStart, "NEG", base);
  }

  /**
   * Generate a NEG to register offset. That is,
   * <PRE>
   * -  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegOff(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RFD(miStart, "NEG", index, scale, disp);
  }

  /**
   * Generate a NEG to absolute address. That is,
   * <PRE>
   * -  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitNEG_Abs(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RA(miStart, "NEG", disp);
  }

  /**
   * Generate a NEG to register offset. That is,
   * <PRE>
   * -  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitNEG_RegIdx(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RXD(miStart, "NEG", base, index, scale, disp);
  }

  /**
   * Generate a NEG on a register. That is,
   * <PRE>
   * -  (byte)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_Reg_Byte(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) 0xF6);
    emitRegRegOperands(reg, GPR.getForOpcode(0x3));
    if (lister != null) lister.R(miStart, "NEG", reg);
  }
  /**
   * Generate a NEG to register-displacement offset. That is,
   * <PRE>
   * -  (byte)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegDisp_Byte(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x3" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RD(miStart, "NEG", base, disp);
  }

  /**
   * Generate a NEG to register indirect. That is,
   * <PRE>
   * -  (byte)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegInd_Byte(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x3" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x3));
    if (lister != null) lister.RN(miStart, "NEG", base);
  }

  /**
   * Generate a NEG to register offset. That is,
   * <PRE>
   * -  (byte)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegOff_Byte(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x3" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RFD(miStart, "NEG", index, scale, disp);
  }

  /**
   * Generate a NEG to absolute address. That is,
   * <PRE>
   * -  (byte)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitNEG_Abs_Byte(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x3" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RA(miStart, "NEG", disp);
  }

  /**
   * Generate a NEG to register offset. That is,
   * <PRE>
   * -  (byte)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitNEG_RegIdx_Byte(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x3" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RXD(miStart, "NEG", base, index, scale, disp);
  }

  /**
   * Generate a NEG on a register. That is,
   * <PRE>
   * -  (word)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_Reg_Word(GPR reg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(reg, GPR.getForOpcode(0x3));
    if (lister != null) lister.R(miStart, "NEG", reg);
  }
  /**
   * Generate a NEG to register-displacement offset. That is,
   * <PRE>
   * -  (word)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegDisp_Word(GPR base, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RD(miStart, "NEG", base, disp);
  }

  /**
   * Generate a NEG to register indirect. That is,
   * <PRE>
   * -  (word)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegInd_Word(GPR base) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x3));
    if (lister != null) lister.RN(miStart, "NEG", base);
  }

  /**
   * Generate a NEG to register offset. That is,
   * <PRE>
   * -  (word)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegOff_Word(GPR index, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RFD(miStart, "NEG", index, scale, disp);
  }

  /**
   * Generate a NEG to absolute address. That is,
   * <PRE>
   * -  (word)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitNEG_Abs_Word(Address disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RA(miStart, "NEG", disp);
  }

  /**
   * Generate a NEG to register offset. That is,
   * <PRE>
   * -  (word)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitNEG_RegIdx_Word(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RXD(miStart, "NEG", base, index, scale, disp);
  }

  /**
   * Generate a NEG on a register. That is,
   * <PRE>
   * -  (quad)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_Reg_Quad(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, reg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(reg, GPR.getForOpcode(0x3));
    if (lister != null) lister.R(miStart, "NEG", reg);
  }
  /**
   * Generate a NEG to register-displacement offset. That is,
   * <PRE>
   * -  (quad)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegDisp_Quad(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RD(miStart, "NEG", base, disp);
  }

  /**
   * Generate a NEG to register indirect. That is,
   * <PRE>
   * -  (quad)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegInd_Quad(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x3));
    if (lister != null) lister.RN(miStart, "NEG", base);
  }

  /**
   * Generate a NEG to register offset. That is,
   * <PRE>
   * -  (quad)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNEG_RegOff_Quad(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, index, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RFD(miStart, "NEG", index, scale, disp);
  }

  /**
   * Generate a NEG to absolute address. That is,
   * <PRE>
   * -  (quad)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitNEG_Abs_Quad(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RA(miStart, "NEG", disp);
  }

  /**
   * Generate a NEG to register offset. That is,
   * <PRE>
   * -  (quad)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitNEG_RegIdx_Quad(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, index, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x3" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RXD(miStart, "NEG", base, index, scale, disp);
  }

  /**
   * Generate a NOT on a register. That is,
   * <PRE>
   * ~  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_Reg(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(reg, GPR.getForOpcode(0x2));
    if (lister != null) lister.R(miStart, "NOT", reg);
  }
  /**
   * Generate a NOT to register-displacement offset. That is,
   * <PRE>
   * ~  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegDisp(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RD(miStart, "NOT", base, disp);
  }

  /**
   * Generate a NOT to register indirect. That is,
   * <PRE>
   * ~  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegInd(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x2));
    if (lister != null) lister.RN(miStart, "NOT", base);
  }

  /**
   * Generate a NOT to register offset. That is,
   * <PRE>
   * ~  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegOff(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RFD(miStart, "NOT", index, scale, disp);
  }

  /**
   * Generate a NOT to absolute address. That is,
   * <PRE>
   * ~  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitNOT_Abs(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RA(miStart, "NOT", disp);
  }

  /**
   * Generate a NOT to register offset. That is,
   * <PRE>
   * ~  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitNOT_RegIdx(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RXD(miStart, "NOT", base, index, scale, disp);
  }

  /**
   * Generate a NOT on a register. That is,
   * <PRE>
   * ~  (byte)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_Reg_Byte(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) 0xF6);
    emitRegRegOperands(reg, GPR.getForOpcode(0x2));
    if (lister != null) lister.R(miStart, "NOT", reg);
  }
  /**
   * Generate a NOT to register-displacement offset. That is,
   * <PRE>
   * ~  (byte)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegDisp_Byte(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x2" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RD(miStart, "NOT", base, disp);
  }

  /**
   * Generate a NOT to register indirect. That is,
   * <PRE>
   * ~  (byte)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegInd_Byte(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x2" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x2));
    if (lister != null) lister.RN(miStart, "NOT", base);
  }

  /**
   * Generate a NOT to register offset. That is,
   * <PRE>
   * ~  (byte)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegOff_Byte(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x2" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RFD(miStart, "NOT", index, scale, disp);
  }

  /**
   * Generate a NOT to absolute address. That is,
   * <PRE>
   * ~  (byte)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitNOT_Abs_Byte(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x2" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RA(miStart, "NOT", disp);
  }

  /**
   * Generate a NOT to register offset. That is,
   * <PRE>
   * ~  (byte)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitNOT_RegIdx_Byte(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xF6);
    // "register 0x2" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RXD(miStart, "NOT", base, index, scale, disp);
  }

  /**
   * Generate a NOT on a register. That is,
   * <PRE>
   * ~  (word)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_Reg_Word(GPR reg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(reg, GPR.getForOpcode(0x2));
    if (lister != null) lister.R(miStart, "NOT", reg);
  }
  /**
   * Generate a NOT to register-displacement offset. That is,
   * <PRE>
   * ~  (word)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegDisp_Word(GPR base, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RD(miStart, "NOT", base, disp);
  }

  /**
   * Generate a NOT to register indirect. That is,
   * <PRE>
   * ~  (word)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegInd_Word(GPR base) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x2));
    if (lister != null) lister.RN(miStart, "NOT", base);
  }

  /**
   * Generate a NOT to register offset. That is,
   * <PRE>
   * ~  (word)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegOff_Word(GPR index, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RFD(miStart, "NOT", index, scale, disp);
  }

  /**
   * Generate a NOT to absolute address. That is,
   * <PRE>
   * ~  (word)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitNOT_Abs_Word(Address disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RA(miStart, "NOT", disp);
  }

  /**
   * Generate a NOT to register offset. That is,
   * <PRE>
   * ~  (word)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitNOT_RegIdx_Word(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RXD(miStart, "NOT", base, index, scale, disp);
  }

  /**
   * Generate a NOT on a register. That is,
   * <PRE>
   * ~  (quad)  reg
   * </PRE>
   *
   * @param reg register to operate upon
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_Reg_Quad(GPR reg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, reg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(reg, GPR.getForOpcode(0x2));
    if (lister != null) lister.R(miStart, "NOT", reg);
  }
  /**
   * Generate a NOT to register-displacement offset. That is,
   * <PRE>
   * ~  (quad)  [base + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegDisp_Quad(GPR base, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RD(miStart, "NOT", base, disp);
  }

  /**
   * Generate a NOT to register indirect. That is,
   * <PRE>
   * ~  (quad)  [reg]
   * </PRE>
   *
   * @param base the destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegInd_Quad(GPR base) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x2));
    if (lister != null) lister.RN(miStart, "NOT", base);
  }

  /**
   * Generate a NOT to register offset. That is,
   * <PRE>
   * ~  (quad)  [index<<scale + disp]
   * </PRE>
   *
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitNOT_RegOff_Quad(GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, index, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RFD(miStart, "NOT", index, scale, disp);
  }

  /**
   * Generate a NOT to absolute address. That is,
   * <PRE>
   * ~  (quad)  [disp]
   * </PRE>
   *
   * @param disp the destination displacement
   */
  public final void emitNOT_Abs_Quad(Address disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitAbsRegOperands(disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RA(miStart, "NOT", disp);
  }

  /**
   * Generate a NOT to register offset. That is,
   * <PRE>
   * ~  (quad)  [base + index<<scale + disp]
   * </PRE>
   *
   * @param base the destination base register
   * @param index the destination index register
   * @param scale the destination shift amount
   * @param disp the destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitNOT_RegIdx_Quad(GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, null, index, base);
    setMachineCodes(mi++, (byte) 0xF7);
    // "register 0x2" is really part of the opcode
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RXD(miStart, "NOT", base, index, scale, disp);
  }

  /**
   * Generate a MUL by register. That is,
   * <PRE>
   * EAX:EDX = EAX * srcReg
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMUL_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcReg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(srcReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.RR(miStart, "MUL", dstReg, srcReg);
  }

  /**
   * Generate a MUL by register displacement. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMUL_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RRD(miStart, "MUL", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a MUL by register indirect. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMUL_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RRN(miStart, "MUL", dstReg, srcBase);
  }

  /**
   * Generate a MUL by register indexed. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMUL_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RRXD(miStart, "MUL", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a MUL by register offseted. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMUL_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, srcIndex, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RRFD(miStart, "MUL", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a MUL by absolute address. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMUL_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RRA(miStart, "MUL", dstReg, srcDisp);
  }

  /**
   * Generate a MUL by register. That is,
   * <PRE>
   * EAX:EDX = EAX * srcReg
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMUL_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcReg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(srcReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.RR(miStart, "MUL", dstReg, srcReg);
  }

  /**
   * Generate a MUL by register displacement. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMUL_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RRD(miStart, "MUL", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a MUL by register indirect. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMUL_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RRN(miStart, "MUL", dstReg, srcBase);
  }

  /**
   * Generate a MUL by register indexed. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMUL_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RRXD(miStart, "MUL", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a MUL by register offseted. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMUL_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, srcIndex, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RRFD(miStart, "MUL", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a MUL by absolute address. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMUL_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RRA(miStart, "MUL", dstReg, srcDisp);
  }

  /**
   * Generate a IMUL1 by register. That is,
   * <PRE>
   * EAX:EDX = EAX * srcReg
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL1_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcReg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(srcReg, GPR.getForOpcode(0x5));
    if (lister != null) lister.RR(miStart, "IMUL1", dstReg, srcReg);
  }

  /**
   * Generate a IMUL1 by register displacement. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL1_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RRD(miStart, "IMUL1", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a IMUL1 by register indirect. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL1_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0x5));
    if (lister != null) lister.RRN(miStart, "IMUL1", dstReg, srcBase);
  }

  /**
   * Generate a IMUL1 by register indexed. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitIMUL1_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RRXD(miStart, "IMUL1", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a IMUL1 by register offseted. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL1_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, srcIndex, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RRFD(miStart, "IMUL1", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a IMUL1 by absolute address. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitIMUL1_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RRA(miStart, "IMUL1", dstReg, srcDisp);
  }

  /**
   * Generate a IMUL1 by register. That is,
   * <PRE>
   * EAX:EDX = EAX * srcReg
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL1_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcReg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(srcReg, GPR.getForOpcode(0x5));
    if (lister != null) lister.RR(miStart, "IMUL1", dstReg, srcReg);
  }

  /**
   * Generate a IMUL1 by register displacement. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL1_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RRD(miStart, "IMUL1", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a IMUL1 by register indirect. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL1_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0x5));
    if (lister != null) lister.RRN(miStart, "IMUL1", dstReg, srcBase);
  }

  /**
   * Generate a IMUL1 by register indexed. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitIMUL1_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RRXD(miStart, "IMUL1", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a IMUL1 by register offseted. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIMUL1_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, srcIndex, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RRFD(miStart, "IMUL1", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a IMUL1 by absolute address. That is,
   * <PRE>
   * EAX:EDX = EAX * [srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitIMUL1_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RRA(miStart, "IMUL1", dstReg, srcDisp);
  }

  /**
   * Generate a DIV by register. That is,
   * <PRE>
   * EAX:EDX = EAX / srcReg
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIV_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcReg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(srcReg, GPR.getForOpcode(0x6));
    if (lister != null) lister.RR(miStart, "DIV", dstReg, srcReg);
  }

  /**
   * Generate a DIV by register displacement. That is,
   * <PRE>
   * EAX:EDX = EAX / [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIV_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RRD(miStart, "DIV", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a DIV by register indirect. That is,
   * <PRE>
   * EAX:EDX = EAX / [srcBase]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIV_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0x6));
    if (lister != null) lister.RRN(miStart, "DIV", dstReg, srcBase);
  }

  /**
   * Generate a DIV by register indexed. That is,
   * <PRE>
   * EAX:EDX = EAX / [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitDIV_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RRXD(miStart, "DIV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a DIV by register offseted. That is,
   * <PRE>
   * EAX:EDX = EAX / [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIV_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, srcIndex, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RRFD(miStart, "DIV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a DIV by absolute address. That is,
   * <PRE>
   * EAX:EDX = EAX / [srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDIV_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RRA(miStart, "DIV", dstReg, srcDisp);
  }

  /**
   * Generate a DIV by register. That is,
   * <PRE>
   * EAX:EDX = EAX / srcReg
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIV_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcReg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(srcReg, GPR.getForOpcode(0x6));
    if (lister != null) lister.RR(miStart, "DIV", dstReg, srcReg);
  }

  /**
   * Generate a DIV by register displacement. That is,
   * <PRE>
   * EAX:EDX = EAX / [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIV_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RRD(miStart, "DIV", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a DIV by register indirect. That is,
   * <PRE>
   * EAX:EDX = EAX / [srcBase]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIV_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0x6));
    if (lister != null) lister.RRN(miStart, "DIV", dstReg, srcBase);
  }

  /**
   * Generate a DIV by register indexed. That is,
   * <PRE>
   * EAX:EDX = EAX / [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitDIV_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RRXD(miStart, "DIV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a DIV by register offseted. That is,
   * <PRE>
   * EAX:EDX = EAX / [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIV_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, srcIndex, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RRFD(miStart, "DIV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a DIV by absolute address. That is,
   * <PRE>
   * EAX:EDX = EAX / [srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDIV_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RRA(miStart, "DIV", dstReg, srcDisp);
  }

  /**
   * Generate a IDIV by register. That is,
   * <PRE>
   * EAX:EDX = EAX u/ srcReg
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIDIV_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcReg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(srcReg, GPR.getForOpcode(0x7));
    if (lister != null) lister.RR(miStart, "IDIV", dstReg, srcReg);
  }

  /**
   * Generate a IDIV by register displacement. That is,
   * <PRE>
   * EAX:EDX = EAX u/ [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIDIV_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RRD(miStart, "IDIV", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a IDIV by register indirect. That is,
   * <PRE>
   * EAX:EDX = EAX u/ [srcBase]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIDIV_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0x7));
    if (lister != null) lister.RRN(miStart, "IDIV", dstReg, srcBase);
  }

  /**
   * Generate a IDIV by register indexed. That is,
   * <PRE>
   * EAX:EDX = EAX u/ [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitIDIV_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RRXD(miStart, "IDIV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a IDIV by register offseted. That is,
   * <PRE>
   * EAX:EDX = EAX u/ [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIDIV_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, srcIndex, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RRFD(miStart, "IDIV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a IDIV by absolute address. That is,
   * <PRE>
   * EAX:EDX = EAX u/ [srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitIDIV_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RRA(miStart, "IDIV", dstReg, srcDisp);
  }

  /**
   * Generate a IDIV by register. That is,
   * <PRE>
   * EAX:EDX = EAX u/ srcReg
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIDIV_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcReg);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegRegOperands(srcReg, GPR.getForOpcode(0x7));
    if (lister != null) lister.RR(miStart, "IDIV", dstReg, srcReg);
  }

  /**
   * Generate a IDIV by register displacement. That is,
   * <PRE>
   * EAX:EDX = EAX u/ [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIDIV_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RRD(miStart, "IDIV", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a IDIV by register indirect. That is,
   * <PRE>
   * EAX:EDX = EAX u/ [srcBase]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIDIV_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0x7));
    if (lister != null) lister.RRN(miStart, "IDIV", dstReg, srcBase);
  }

  /**
   * Generate a IDIV by register indexed. That is,
   * <PRE>
   * EAX:EDX = EAX u/ [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitIDIV_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0xF7);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RRXD(miStart, "IDIV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a IDIV by register offseted. That is,
   * <PRE>
   * EAX:EDX = EAX u/ [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitIDIV_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, srcIndex, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RRFD(miStart, "IDIV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a IDIV by absolute address. That is,
   * <PRE>
   * EAX:EDX = EAX u/ [srcDisp]
   * </PRE>
   *
   * @param dstReg must always be EAX/R0
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitIDIV_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dstReg == EAX);
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xF7);
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RRA(miStart, "IDIV", dstReg, srcDisp);
  }

  /**
   * Generate a register(indirect)--register MOV. That is,
   * <PRE>
   * [dstBase] :=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOV", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOV. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] :=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOV_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOV", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOV. That is,
   * <PRE>
   * [dstDisp] :=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOV_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOV", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOV. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] :=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOV_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOV", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOV. That is,
   * <PRE>
   * [dstBase + dstDisp] :=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOV_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOV", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register MOV. That is,
   * <PRE>
   * dstReg :=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "MOV", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOV. That is,
   * <PRE>
   * dstReg :=  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOV", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOV", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOV_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) MOV. That is,
   * <PRE>
   * dstReg :=  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOV", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register MOV. That is,
   * <PRE>
   * [dstBase] :=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x88);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOV", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOV. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] :=  (byte)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOV_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x88);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOV", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOV. That is,
   * <PRE>
   * [dstDisp] :=  (byte)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOV_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x88);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOV", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOV. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] :=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOV_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x88);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOV", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOV. That is,
   * <PRE>
   * [dstBase + dstDisp] :=  (byte)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOV_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x88);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOV", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register MOV. That is,
   * <PRE>
   * dstReg :=  (byte)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x88);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "MOV", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOV. That is,
   * <PRE>
   * dstReg :=  (byte)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOV", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  (byte)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  (byte)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOV", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  (byte)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOV_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) MOV. That is,
   * <PRE>
   * dstReg :=  (byte)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOV", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register MOV. That is,
   * <PRE>
   * [dstBase] :=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOV", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOV. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] :=  (word)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOV_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOV", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOV. That is,
   * <PRE>
   * [dstDisp] :=  (word)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOV_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOV", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOV. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] :=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOV_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOV", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOV. That is,
   * <PRE>
   * [dstBase + dstDisp] :=  (word)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOV_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOV", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register MOV. That is,
   * <PRE>
   * dstReg :=  (word)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "MOV", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOV. That is,
   * <PRE>
   * dstReg :=  (word)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOV", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  (word)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  (word)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOV", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  (word)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOV_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) MOV. That is,
   * <PRE>
   * dstReg :=  (word)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOV", dstReg, srcBase);
  }

  /**
   * Generate a register(indirect)--register MOV. That is,
   * <PRE>
   * [dstBase] :=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOV", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOV. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] :=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOV_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOV", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOV. That is,
   * <PRE>
   * [dstDisp] :=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOV_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOV", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOV. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] :=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOV_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOV", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOV. That is,
   * <PRE>
   * [dstBase + dstDisp] :=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOV_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOV", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register MOV. That is,
   * <PRE>
   * dstReg :=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x89);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "MOV", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOV. That is,
   * <PRE>
   * dstReg :=  (quad)  [srcReg + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOV", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, null);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOV", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-offset MOV. That is,
   * <PRE>
   * dstReg :=  (quad)  [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source shift amount
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOV_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register(indirect) MOV. That is,
   * <PRE>
   * dstReg :=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, dstReg, null, srcBase);
    // single byte opcode
    setMachineCodes(mi++, (byte) 0x8B);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOV", dstReg, srcBase);
  }

  /**
   * Generate a register-indirect--immediate MOV. That is,
   * <PRE>
   * [dstBase] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xC6);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RNI(miStart, "MOV", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate MOV. That is,
   * <PRE>
   * [dstBase + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xC6);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RDI(miStart, "MOV", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate MOV. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xC6);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RXDI(miStart, "MOV", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate MOV. That is,
   * <PRE>
   * [dstIndex<<scale + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xC6);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RFDI(miStart, "MOV", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate an absolute MOV. That is,
   * <PRE>
   * [dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitMOV_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xC6);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    emitImm8(imm);
    if (lister != null) lister.RAI(miStart, "MOV", dstDisp, imm);
  }

  /**
   * Generate a register-indirect--immediate MOV. That is,
   * <PRE>
   * [dstBase] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    emitImm16(imm);
    if (lister != null) lister.RNI(miStart, "MOV", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate MOV. That is,
   * <PRE>
   * [dstBase + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    emitImm16(imm);
    if (lister != null) lister.RDI(miStart, "MOV", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate MOV. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xC7);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm16(imm);
    if (lister != null) lister.RXDI(miStart, "MOV", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate MOV. That is,
   * <PRE>
   * [dstIndex<<scale + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm16(imm);
    if (lister != null) lister.RFDI(miStart, "MOV", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate an absolute MOV. That is,
   * <PRE>
   * [dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitMOV_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xC7);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    emitImm16(imm);
    if (lister != null) lister.RAI(miStart, "MOV", dstDisp, imm);
  }

  /**
   * Generate a register-indirect--immediate MOV. That is,
   * <PRE>
   * [dstBase] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    emitImm32(imm);
    if (lister != null) lister.RNI(miStart, "MOV", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate MOV. That is,
   * <PRE>
   * [dstBase + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    emitImm32(imm);
    if (lister != null) lister.RDI(miStart, "MOV", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate MOV. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xC7);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm32(imm);
    if (lister != null) lister.RXDI(miStart, "MOV", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate MOV. That is,
   * <PRE>
   * [dstIndex<<scale + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm32(imm);
    if (lister != null) lister.RFDI(miStart, "MOV", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate an absolute MOV. That is,
   * <PRE>
   * [dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitMOV_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xC7);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    emitImm32(imm);
    if (lister != null) lister.RAI(miStart, "MOV", dstDisp, imm);
  }

  /**
   * Generate a register-indirect--immediate MOV. That is,
   * <PRE>
   * [dstBase] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    emitImm32(imm);
    if (lister != null) lister.RNI(miStart, "MOV", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate MOV. That is,
   * <PRE>
   * [dstBase + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    emitImm32(imm);
    if (lister != null) lister.RDI(miStart, "MOV", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate MOV. That is,
   * <PRE>
   * [dstBase + dstIndex<<scale + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOV_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(true, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xC7);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm32(imm);
    if (lister != null) lister.RXDI(miStart, "MOV", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate MOV. That is,
   * <PRE>
   * [dstIndex<<scale + dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOV_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(true, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xC7);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    emitImm32(imm);
    if (lister != null) lister.RFDI(miStart, "MOV", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate an absolute MOV. That is,
   * <PRE>
   * [dstDisp] MOV = imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitMOV_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    // no prefix byte
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xC7);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    emitImm32(imm);
    if (lister != null) lister.RAI(miStart, "MOV", dstDisp, imm);
  }

  /**
   * Generate a move sign extended from register. That is,
   * <PRE>
   * dstReg := (byte) srcReg (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSX_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVSX", dstReg, srcReg);
  }

  /**
   * Generate a move sign extended from register displacement. That is,
   * <PRE>
   * dstReg := (byte) [srcBase + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSX_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVSX", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a move sign extended from register indirect. That is,
   * <PRE>
   * dstReg := (byte) [srcBase] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSX_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVSX", dstReg, srcBase);
  }

  /**
   * Generate a move sign extended from register offset. That is,
   * <PRE>
   * dstReg := (byte) [srcIndex<<srcScale + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSX_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVSX", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move sign extended from an absolute address. That is,
   * <PRE>
   * dstReg := (byte) [srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVSX_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVSX", dstReg, srcDisp);
  }

  /**
   * Generate a move sign extended by register indexed. That is,
   * <PRE>
   * dstReg := (byte) [srcBase + srcIndex<<srcScale + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVSX_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVSX", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move sign extended from register. That is,
   * <PRE>
   * dstReg := (word) srcReg (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSX_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVSX", dstReg, srcReg);
  }

  /**
   * Generate a move sign extended from register displacement. That is,
   * <PRE>
   * dstReg := (word) [srcBase + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSX_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVSX", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a move sign extended from register indirect. That is,
   * <PRE>
   * dstReg := (word) [srcBase] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSX_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVSX", dstReg, srcBase);
  }

  /**
   * Generate a move sign extended from register offset. That is,
   * <PRE>
   * dstReg := (word) [srcIndex<<srcScale + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSX_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVSX", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move sign extended from an absolute address. That is,
   * <PRE>
   * dstReg := (word) [srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVSX_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVSX", dstReg, srcDisp);
  }

  /**
   * Generate a move sign extended by register indexed. That is,
   * <PRE>
   * dstReg := (word) [srcBase + srcIndex<<srcScale + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVSX_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVSX", dstReg, srcBase, srcIndex, srcScale, srcDisp);
    }

  /**
   * Generate a move sign extended from register. That is,
   * <PRE>
   * dstReg := (byte) srcReg (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSXQ_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVSXQ", dstReg, srcReg);
  }

  /**
   * Generate a move sign extended from register displacement. That is,
   * <PRE>
   * dstReg := (byte) [srcBase + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSXQ_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVSXQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a move sign extended from register indirect. That is,
   * <PRE>
   * dstReg := (byte) [srcBase] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSXQ_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVSXQ", dstReg, srcBase);
  }

  /**
   * Generate a move sign extended from register offset. That is,
   * <PRE>
   * dstReg := (byte) [srcIndex<<srcScale + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSXQ_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVSXQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move sign extended from an absolute address. That is,
   * <PRE>
   * dstReg := (byte) [srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVSXQ_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVSXQ", dstReg, srcDisp);
  }

  /**
   * Generate a move sign extended by register indexed. That is,
   * <PRE>
   * dstReg := (byte) [srcBase + srcIndex<<srcScale + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVSXQ_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBE);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVSXQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move sign extended from register. That is,
   * <PRE>
   * dstReg := (word) srcReg (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSXQ_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVSXQ", dstReg, srcReg);
  }

  /**
   * Generate a move sign extended from register displacement. That is,
   * <PRE>
   * dstReg := (word) [srcBase + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSXQ_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVSXQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a move sign extended from register indirect. That is,
   * <PRE>
   * dstReg := (word) [srcBase] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSXQ_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVSXQ", dstReg, srcBase);
  }

  /**
   * Generate a move sign extended from register offset. That is,
   * <PRE>
   * dstReg := (word) [srcIndex<<srcScale + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSXQ_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVSXQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move sign extended from an absolute address. That is,
   * <PRE>
   * dstReg := (word) [srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVSXQ_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVSXQ", dstReg, srcDisp);
  }

  /**
   * Generate a move sign extended by register indexed. That is,
   * <PRE>
   * dstReg := (word) [srcBase + srcIndex<<srcScale + srcDisp] (sign extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVSXQ_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xBF);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVSXQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
    }

  /**
   * Generate a move zero extended from register. That is,
   * <PRE>
   * dstReg := (byte) srcReg (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZX_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVZX", dstReg, srcReg);
  }

  /**
   * Generate a move zero extended from register displacement. That is,
   * <PRE>
   * dstReg := (byte) [srcBase + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZX_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVZX", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a move zero extended from register indirect. That is,
   * <PRE>
   * dstReg := (byte) [srcBase] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZX_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVZX", dstReg, srcBase);
  }

  /**
   * Generate a move zero extended from register offset. That is,
   * <PRE>
   * dstReg := (byte) [srcIndex<<srcScale + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZX_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVZX", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move zero extended from an absolute address. That is,
   * <PRE>
   * dstReg := (byte) [srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVZX_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVZX", dstReg, srcDisp);
  }

  /**
   * Generate a move zero extended by register indexed. That is,
   * <PRE>
   * dstReg := (byte) [srcBase + srcIndex<<srcScale + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVZX_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVZX", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move zero extended from register. That is,
   * <PRE>
   * dstReg := (word) srcReg (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZX_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVZX", dstReg, srcReg);
  }

  /**
   * Generate a move zero extended from register displacement. That is,
   * <PRE>
   * dstReg := (word) [srcBase + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZX_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVZX", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a move zero extended from register indirect. That is,
   * <PRE>
   * dstReg := (word) [srcBase] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZX_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVZX", dstReg, srcBase);
  }

  /**
   * Generate a move zero extended from register offset. That is,
   * <PRE>
   * dstReg := (word) [srcIndex<<srcScale + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZX_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVZX", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move zero extended from an absolute address. That is,
   * <PRE>
   * dstReg := (word) [srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVZX_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVZX", dstReg, srcDisp);
  }

  /**
   * Generate a move zero extended by register indexed. That is,
   * <PRE>
   * dstReg := (word) [srcBase + srcIndex<<srcScale + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVZX_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVZX", dstReg, srcBase, srcIndex, srcScale, srcDisp);
    }

  /**
   * Generate a move zero extended from register. That is,
   * <PRE>
   * dstReg := (byte) srcReg (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZXQ_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVZXQ", dstReg, srcReg);
  }

  /**
   * Generate a move zero extended from register displacement. That is,
   * <PRE>
   * dstReg := (byte) [srcBase + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZXQ_Reg_RegDisp_Byte(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVZXQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a move zero extended from register indirect. That is,
   * <PRE>
   * dstReg := (byte) [srcBase] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZXQ_Reg_RegInd_Byte(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVZXQ", dstReg, srcBase);
  }

  /**
   * Generate a move zero extended from register offset. That is,
   * <PRE>
   * dstReg := (byte) [srcIndex<<srcScale + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZXQ_Reg_RegOff_Byte(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVZXQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move zero extended from an absolute address. That is,
   * <PRE>
   * dstReg := (byte) [srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVZXQ_Reg_Abs_Byte(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVZXQ", dstReg, srcDisp);
  }

  /**
   * Generate a move zero extended by register indexed. That is,
   * <PRE>
   * dstReg := (byte) [srcBase + srcIndex<<srcScale + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVZXQ_Reg_RegIdx_Byte(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB6);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVZXQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move zero extended from register. That is,
   * <PRE>
   * dstReg := (word) srcReg (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZXQ_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVZXQ", dstReg, srcReg);
  }

  /**
   * Generate a move zero extended from register displacement. That is,
   * <PRE>
   * dstReg := (word) [srcBase + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZXQ_Reg_RegDisp_Word(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVZXQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a move zero extended from register indirect. That is,
   * <PRE>
   * dstReg := (word) [srcBase] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZXQ_Reg_RegInd_Word(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVZXQ", dstReg, srcBase);
  }

  /**
   * Generate a move zero extended from register offset. That is,
   * <PRE>
   * dstReg := (word) [srcIndex<<srcScale + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVZXQ_Reg_RegOff_Word(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVZXQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a move zero extended from an absolute address. That is,
   * <PRE>
   * dstReg := (word) [srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVZXQ_Reg_Abs_Word(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVZXQ", dstReg, srcDisp);
  }

  /**
   * Generate a move zero extended by register indexed. That is,
   * <PRE>
   * dstReg := (word) [srcBase + srcIndex<<srcScale + srcDisp] (zero extended)
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale of the index
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVZXQ_Reg_RegIdx_Word(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB7);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVZXQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
    }

  /**
   * Generate a register(indirect)--register CMPXCHG. That is,
   * <PRE>
   * [dstBase] <->=  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPXCHG_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "CMPXCHG", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register CMPXCHG. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] <->=  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitCMPXCHG_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "CMPXCHG", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register CMPXCHG. That is,
   * <PRE>
   * [dstDisp] <->=  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitCMPXCHG_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "CMPXCHG", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register CMPXCHG. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] <->=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitCMPXCHG_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "CMPXCHG", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register CMPXCHG. That is,
   * <PRE>
   * [dstBase + dstDisp] <->=  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitCMPXCHG_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "CMPXCHG", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register CMPXCHG. That is,
   * <PRE>
   * dstReg <->=  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPXCHG_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(false, srcReg, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "CMPXCHG", dstReg, srcReg);
  }

  /**
   * Generate a register(indirect)--register CMPXCHG. That is,
   * <PRE>
   * [dstBase] <->=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPXCHG_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "CMPXCHG", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register CMPXCHG. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] <->=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitCMPXCHG_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "CMPXCHG", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register CMPXCHG. That is,
   * <PRE>
   * [dstDisp] <->=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination address
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitCMPXCHG_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "CMPXCHG", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register CMPXCHG. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] <->=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitCMPXCHG_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "CMPXCHG", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register CMPXCHG. That is,
   * <PRE>
   * [dstBase + dstDisp] <->=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitCMPXCHG_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "CMPXCHG", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register--register CMPXCHG. That is,
   * <PRE>
   * dstReg <->=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPXCHG_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    // no group 1 to 4 prefix byte
    generateREXprefix(true, srcReg, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xB1);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "CMPXCHG", dstReg, srcReg);
  }

  /**
   * Generate a register--immediate ROL. That is,
   * <PRE>
   * rotate left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "ROL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "ROL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "ROL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "ROL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitROL_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "ROL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "ROL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register ROL. That is,
   * <PRE>
   * rotate left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
    if (lister != null) lister.RR(miStart, "ROL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    if (lister != null) lister.RNR(miStart, "ROL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitROL_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RDR(miStart, "ROL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register ROL. That is,
   * <PRE>
   * rotate left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitROL_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RFDR(miStart, "ROL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register ROL. That is,
   * <PRE>
   * rotate left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitROL_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RAR(miStart, "ROL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitROL_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RXDR(miStart, "ROL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate ROL. That is,
   * <PRE>
   * rotate left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "ROL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "ROL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "ROL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "ROL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitROL_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "ROL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "ROL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register ROL. That is,
   * <PRE>
   * rotate left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
    if (lister != null) lister.RR(miStart, "ROL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    if (lister != null) lister.RNR(miStart, "ROL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitROL_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RDR(miStart, "ROL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register ROL. That is,
   * <PRE>
   * rotate left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitROL_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RFDR(miStart, "ROL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register ROL. That is,
   * <PRE>
   * rotate left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitROL_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RAR(miStart, "ROL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitROL_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RXDR(miStart, "ROL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate ROL. That is,
   * <PRE>
   * rotate left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "ROL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "ROL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "ROL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "ROL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitROL_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "ROL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "ROL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register ROL. That is,
   * <PRE>
   * rotate left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
    if (lister != null) lister.RR(miStart, "ROL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    if (lister != null) lister.RNR(miStart, "ROL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitROL_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RDR(miStart, "ROL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register ROL. That is,
   * <PRE>
   * rotate left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitROL_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RFDR(miStart, "ROL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register ROL. That is,
   * <PRE>
   * rotate left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitROL_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RAR(miStart, "ROL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitROL_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RXDR(miStart, "ROL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate ROL. That is,
   * <PRE>
   * rotate left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "ROL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "ROL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "ROL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROL_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "ROL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitROL_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "ROL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "ROL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register ROL. That is,
   * <PRE>
   * rotate left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x0));
    if (lister != null) lister.RR(miStart, "ROL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROL_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x0));
    if (lister != null) lister.RNR(miStart, "ROL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitROL_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RDR(miStart, "ROL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register ROL. That is,
   * <PRE>
   * rotate left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitROL_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RFDR(miStart, "ROL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register ROL. That is,
   * <PRE>
   * rotate left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitROL_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RAR(miStart, "ROL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ROL. That is,
   * <PRE>
   * rotate left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitROL_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RXDR(miStart, "ROL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate ROR. That is,
   * <PRE>
   * rotate right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "ROR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "ROR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "ROR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "ROR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitROR_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "ROR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "ROR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register ROR. That is,
   * <PRE>
   * rotate right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
    if (lister != null) lister.RR(miStart, "ROR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
    if (lister != null) lister.RNR(miStart, "ROR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitROR_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RDR(miStart, "ROR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register ROR. That is,
   * <PRE>
   * rotate right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitROR_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RFDR(miStart, "ROR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register ROR. That is,
   * <PRE>
   * rotate right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitROR_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RAR(miStart, "ROR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitROR_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RXDR(miStart, "ROR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate ROR. That is,
   * <PRE>
   * rotate right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "ROR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "ROR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "ROR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "ROR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitROR_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "ROR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "ROR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register ROR. That is,
   * <PRE>
   * rotate right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
    if (lister != null) lister.RR(miStart, "ROR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
    if (lister != null) lister.RNR(miStart, "ROR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitROR_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RDR(miStart, "ROR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register ROR. That is,
   * <PRE>
   * rotate right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitROR_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RFDR(miStart, "ROR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register ROR. That is,
   * <PRE>
   * rotate right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitROR_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RAR(miStart, "ROR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitROR_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RXDR(miStart, "ROR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate ROR. That is,
   * <PRE>
   * rotate right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "ROR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "ROR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "ROR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "ROR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitROR_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "ROR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "ROR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register ROR. That is,
   * <PRE>
   * rotate right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
    if (lister != null) lister.RR(miStart, "ROR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
    if (lister != null) lister.RNR(miStart, "ROR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitROR_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RDR(miStart, "ROR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register ROR. That is,
   * <PRE>
   * rotate right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitROR_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RFDR(miStart, "ROR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register ROR. That is,
   * <PRE>
   * rotate right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitROR_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RAR(miStart, "ROR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitROR_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RXDR(miStart, "ROR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate ROR. That is,
   * <PRE>
   * rotate right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "ROR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "ROR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "ROR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitROR_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "ROR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitROR_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "ROR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "ROR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register ROR. That is,
   * <PRE>
   * rotate right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x1));
    if (lister != null) lister.RR(miStart, "ROR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitROR_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x1));
    if (lister != null) lister.RNR(miStart, "ROR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitROR_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RDR(miStart, "ROR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register ROR. That is,
   * <PRE>
   * rotate right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitROR_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RFDR(miStart, "ROR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register ROR. That is,
   * <PRE>
   * rotate right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitROR_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RAR(miStart, "ROR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register ROR. That is,
   * <PRE>
   * rotate right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitROR_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x1));
    if (lister != null) lister.RXDR(miStart, "ROR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "RCL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "RCL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "RCL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "RCL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitRCL_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "RCL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "RCL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register RCL. That is,
   * <PRE>
   * rotate left with carry of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
    if (lister != null) lister.RR(miStart, "RCL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
    if (lister != null) lister.RNR(miStart, "RCL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitRCL_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RDR(miStart, "RCL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register RCL. That is,
   * <PRE>
   * rotate left with carry of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitRCL_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RFDR(miStart, "RCL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register RCL. That is,
   * <PRE>
   * rotate left with carry of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitRCL_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RAR(miStart, "RCL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitRCL_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RXDR(miStart, "RCL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "RCL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "RCL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "RCL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "RCL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitRCL_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "RCL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "RCL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register RCL. That is,
   * <PRE>
   * rotate left with carry of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
    if (lister != null) lister.RR(miStart, "RCL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
    if (lister != null) lister.RNR(miStart, "RCL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitRCL_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RDR(miStart, "RCL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register RCL. That is,
   * <PRE>
   * rotate left with carry of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitRCL_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RFDR(miStart, "RCL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register RCL. That is,
   * <PRE>
   * rotate left with carry of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitRCL_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RAR(miStart, "RCL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register RCL. That is,
   * <PRE>
   * rotate left with carry of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitRCL_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RXDR(miStart, "RCL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "RCL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "RCL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "RCL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "RCL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitRCL_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "RCL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "RCL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register RCL. That is,
   * <PRE>
   * rotate left with carry  of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
    if (lister != null) lister.RR(miStart, "RCL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
    if (lister != null) lister.RNR(miStart, "RCL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitRCL_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RDR(miStart, "RCL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitRCL_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RFDR(miStart, "RCL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitRCL_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RAR(miStart, "RCL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitRCL_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RXDR(miStart, "RCL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "RCL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "RCL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "RCL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCL_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "RCL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitRCL_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "RCL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "RCL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register RCL. That is,
   * <PRE>
   * rotate left with carry  of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x2));
    if (lister != null) lister.RR(miStart, "RCL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCL_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x2));
    if (lister != null) lister.RNR(miStart, "RCL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitRCL_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RDR(miStart, "RCL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitRCL_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RFDR(miStart, "RCL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitRCL_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RAR(miStart, "RCL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register RCL. That is,
   * <PRE>
   * rotate left with carry  of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitRCL_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x2));
    if (lister != null) lister.RXDR(miStart, "RCL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "RCR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "RCR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "RCR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "RCR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitRCR_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "RCR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "RCR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register RCR. That is,
   * <PRE>
   * rotate right with carry of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
    if (lister != null) lister.RR(miStart, "RCR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
    if (lister != null) lister.RNR(miStart, "RCR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitRCR_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RDR(miStart, "RCR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitRCR_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RFDR(miStart, "RCR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitRCR_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RAR(miStart, "RCR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitRCR_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RXDR(miStart, "RCR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "RCR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "RCR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "RCR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "RCR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitRCR_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "RCR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "RCR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register RCR. That is,
   * <PRE>
   * rotate right with carry of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
    if (lister != null) lister.RR(miStart, "RCR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
    if (lister != null) lister.RNR(miStart, "RCR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitRCR_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RDR(miStart, "RCR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitRCR_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RFDR(miStart, "RCR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitRCR_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RAR(miStart, "RCR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitRCR_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RXDR(miStart, "RCR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "RCR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "RCR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "RCR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "RCR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitRCR_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "RCR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "RCR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register RCR. That is,
   * <PRE>
   * rotate right with carry of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
    if (lister != null) lister.RR(miStart, "RCR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
    if (lister != null) lister.RNR(miStart, "RCR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitRCR_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RDR(miStart, "RCR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitRCR_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RFDR(miStart, "RCR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitRCR_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RAR(miStart, "RCR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitRCR_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RXDR(miStart, "RCR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "RCR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "RCR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "RCR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitRCR_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "RCR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitRCR_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "RCR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "RCR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register RCR. That is,
   * <PRE>
   * rotate right with carry of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x3));
    if (lister != null) lister.RR(miStart, "RCR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitRCR_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x3));
    if (lister != null) lister.RNR(miStart, "RCR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitRCR_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RDR(miStart, "RCR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitRCR_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RFDR(miStart, "RCR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitRCR_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RAR(miStart, "RCR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register RCR. That is,
   * <PRE>
   * rotate right with carry of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitRCR_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x3));
    if (lister != null) lister.RXDR(miStart, "RCR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SAL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SAL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SAL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SAL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSAL_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SAL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SAL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SAL. That is,
   * <PRE>
   * arithemetic shift left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.RR(miStart, "SAL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RNR(miStart, "SAL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSAL_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RDR(miStart, "SAL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSAL_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RFDR(miStart, "SAL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSAL_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RAR(miStart, "SAL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSAL_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RXDR(miStart, "SAL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SAL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SAL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SAL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SAL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSAL_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SAL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SAL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SAL. That is,
   * <PRE>
   * arithemetic shift left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.RR(miStart, "SAL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RNR(miStart, "SAL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSAL_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RDR(miStart, "SAL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSAL_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RFDR(miStart, "SAL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSAL_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RAR(miStart, "SAL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSAL_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RXDR(miStart, "SAL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SAL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SAL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SAL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SAL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSAL_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SAL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SAL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SAL. That is,
   * <PRE>
   * arithemetic shift left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.RR(miStart, "SAL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RNR(miStart, "SAL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSAL_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RDR(miStart, "SAL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSAL_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RFDR(miStart, "SAL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSAL_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RAR(miStart, "SAL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSAL_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RXDR(miStart, "SAL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SAL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SAL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SAL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAL_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SAL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSAL_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SAL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SAL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SAL. That is,
   * <PRE>
   * arithemetic shift left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.RR(miStart, "SAL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAL_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RNR(miStart, "SAL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSAL_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RDR(miStart, "SAL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSAL_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RFDR(miStart, "SAL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSAL_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RAR(miStart, "SAL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SAL. That is,
   * <PRE>
   * arithemetic shift left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSAL_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RXDR(miStart, "SAL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SHL. That is,
   * <PRE>
   * logical shift left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SHL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SHL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SHL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SHL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSHL_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SHL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SHL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SHL. That is,
   * <PRE>
   * logical shift left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.RR(miStart, "SHL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RNR(miStart, "SHL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHL_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RDR(miStart, "SHL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SHL. That is,
   * <PRE>
   * logical shift left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHL_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RFDR(miStart, "SHL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SHL. That is,
   * <PRE>
   * logical shift left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHL_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RAR(miStart, "SHL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHL_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RXDR(miStart, "SHL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SHL. That is,
   * <PRE>
   * logical shift left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SHL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SHL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SHL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SHL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSHL_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SHL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SHL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SHL. That is,
   * <PRE>
   * logical shift left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.RR(miStart, "SHL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RNR(miStart, "SHL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHL_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RDR(miStart, "SHL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SHL. That is,
   * <PRE>
   * logical shift left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHL_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RFDR(miStart, "SHL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SHL. That is,
   * <PRE>
   * logical shift left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHL_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RAR(miStart, "SHL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHL_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RXDR(miStart, "SHL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SHL. That is,
   * <PRE>
   * logical shift left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SHL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SHL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SHL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SHL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSHL_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SHL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SHL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SHL. That is,
   * <PRE>
   * logical shift left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.RR(miStart, "SHL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RNR(miStart, "SHL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHL_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RDR(miStart, "SHL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SHL. That is,
   * <PRE>
   * logical shift left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHL_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RFDR(miStart, "SHL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SHL. That is,
   * <PRE>
   * logical shift left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHL_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RAR(miStart, "SHL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHL_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RXDR(miStart, "SHL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SHL. That is,
   * <PRE>
   * logical shift left of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SHL", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SHL", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SHL", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHL_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SHL", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSHL_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SHL", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SHL", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SHL. That is,
   * <PRE>
   * logical shift left of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x4));
    if (lister != null) lister.RR(miStart, "SHL", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHL_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x4));
    if (lister != null) lister.RNR(miStart, "SHL", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHL_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RDR(miStart, "SHL", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SHL. That is,
   * <PRE>
   * logical shift left of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHL_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RFDR(miStart, "SHL", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SHL. That is,
   * <PRE>
   * logical shift left of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHL_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RAR(miStart, "SHL", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SHL. That is,
   * <PRE>
   * logical shift left of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHL_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x4));
    if (lister != null) lister.RXDR(miStart, "SHL", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SHR. That is,
   * <PRE>
   * logical shift right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SHR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SHR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SHR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SHR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSHR_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SHR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SHR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SHR. That is,
   * <PRE>
   * logical shift right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
    if (lister != null) lister.RR(miStart, "SHR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
    if (lister != null) lister.RNR(miStart, "SHR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHR_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RDR(miStart, "SHR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SHR. That is,
   * <PRE>
   * logical shift right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHR_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RFDR(miStart, "SHR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SHR. That is,
   * <PRE>
   * logical shift right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHR_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RAR(miStart, "SHR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHR_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RXDR(miStart, "SHR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SHR. That is,
   * <PRE>
   * logical shift right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SHR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SHR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SHR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SHR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSHR_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SHR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SHR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SHR. That is,
   * <PRE>
   * logical shift right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
    if (lister != null) lister.RR(miStart, "SHR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
    if (lister != null) lister.RNR(miStart, "SHR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHR_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RDR(miStart, "SHR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SHR. That is,
   * <PRE>
   * logical shift right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHR_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RFDR(miStart, "SHR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SHR. That is,
   * <PRE>
   * logical shift right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHR_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RAR(miStart, "SHR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHR_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RXDR(miStart, "SHR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SHR. That is,
   * <PRE>
   * logical shift right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SHR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SHR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SHR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SHR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSHR_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SHR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SHR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SHR. That is,
   * <PRE>
   * logical shift right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
    if (lister != null) lister.RR(miStart, "SHR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
    if (lister != null) lister.RNR(miStart, "SHR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHR_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RDR(miStart, "SHR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SHR. That is,
   * <PRE>
   * logical shift right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHR_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RFDR(miStart, "SHR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SHR. That is,
   * <PRE>
   * logical shift right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHR_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RAR(miStart, "SHR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHR_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RXDR(miStart, "SHR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SHR. That is,
   * <PRE>
   * logical shift right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SHR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SHR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SHR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSHR_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SHR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSHR_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SHR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SHR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SHR. That is,
   * <PRE>
   * logical shift right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x5));
    if (lister != null) lister.RR(miStart, "SHR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHR_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x5));
    if (lister != null) lister.RNR(miStart, "SHR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHR_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RDR(miStart, "SHR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SHR. That is,
   * <PRE>
   * logical shift right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHR_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RFDR(miStart, "SHR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SHR. That is,
   * <PRE>
   * logical shift right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHR_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RAR(miStart, "SHR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SHR. That is,
   * <PRE>
   * logical shift right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHR_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x5));
    if (lister != null) lister.RXDR(miStart, "SHR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_Reg_Imm_Byte(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SAR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegInd_Imm_Byte(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SAR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegDisp_Imm_Byte(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SAR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegOff_Imm_Byte(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SAR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSAR_Abs_Imm_Byte(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SAR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_RegIdx_Imm_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC0);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SAR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SAR. That is,
   * <PRE>
   * arithemetic shift right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_Reg_Reg_Byte(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
    if (lister != null) lister.RR(miStart, "SAR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_RegInd_Reg_Byte(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
    if (lister != null) lister.RNR(miStart, "SAR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSAR_RegDisp_Reg_Byte(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RDR(miStart, "SAR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSAR_RegOff_Reg_Byte(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RFDR(miStart, "SAR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSAR_Abs_Reg_Byte(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD2);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RAR(miStart, "SAR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSAR_RegIdx_Reg_Byte(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD2);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RXDR(miStart, "SAR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_Reg_Imm_Word(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SAR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegInd_Imm_Word(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SAR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegDisp_Imm_Word(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SAR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegOff_Imm_Word(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SAR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSAR_Abs_Imm_Word(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SAR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_RegIdx_Imm_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SAR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SAR. That is,
   * <PRE>
   * arithemetic shift right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_Reg_Reg_Word(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
    if (lister != null) lister.RR(miStart, "SAR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_RegInd_Reg_Word(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
    if (lister != null) lister.RNR(miStart, "SAR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSAR_RegDisp_Reg_Word(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RDR(miStart, "SAR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSAR_RegOff_Reg_Word(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RFDR(miStart, "SAR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSAR_Abs_Reg_Word(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RAR(miStart, "SAR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSAR_RegIdx_Reg_Word(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RXDR(miStart, "SAR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_Reg_Imm(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SAR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegInd_Imm(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SAR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegDisp_Imm(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SAR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegOff_Imm(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SAR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSAR_Abs_Imm(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SAR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_RegIdx_Imm(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SAR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SAR. That is,
   * <PRE>
   * arithemetic shift right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_Reg_Reg(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
    if (lister != null) lister.RR(miStart, "SAR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_RegInd_Reg(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
    if (lister != null) lister.RNR(miStart, "SAR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSAR_RegDisp_Reg(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RDR(miStart, "SAR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSAR_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RFDR(miStart, "SAR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSAR_Abs_Reg(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RAR(miStart, "SAR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSAR_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(false, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RXDR(miStart, "SAR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of dstReg by imm
   * </PRE>
   *
   * @param dstReg the destination register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_Reg_Imm_Quad(GPR dstReg, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RI(miStart, "SAR", dstReg, imm);
  }

  /**
   * Generate a register-indirect--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegInd_Imm_Quad(GPR dstBase, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RNI(miStart, "SAR", dstBase, imm);
  }

  /**
   * Generate a register-displacement--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegDisp_Imm_Quad(GPR dstBase, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RDI(miStart, "SAR", dstBase, dstDisp, imm);
  }

  /**
   * Generate a register-offset--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSAR_RegOff_Imm_Quad(GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RFDI(miStart, "SAR", dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a absolute--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstDisp] by imm
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  public final void emitSAR_Abs_Imm_Quad(Address dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, null, null);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RAI(miStart, "SAR", dstDisp, imm);
  }

  /**
   * Generate a register-index--immediate SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstIndex<<dstScale + dstDisp] by imm
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param imm immediate
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_RegIdx_Imm_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, int imm) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(fits(imm,8));
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    if (imm == 1) {
      setMachineCodes(mi++, (byte) 0xD1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    } else {
      setMachineCodes(mi++, (byte) 0xC1);
      emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
      emitImm8((byte)imm);
    }
    if (lister != null) lister.RXDI(miStart, "SAR", dstBase, dstIndex, dstScale, dstDisp, imm);
  }

  /**
   * Generate a register--register SAR. That is,
   * <PRE>
   * arithemetic shift right of dstReg by srcReg
   * </PRE>
   *
   * @param dstReg the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_Reg_Reg_Quad(GPR dstReg, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstReg);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(dstReg, GPR.getForOpcode(0x7));
    if (lister != null) lister.RR(miStart, "SAR", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase] by srcReg
   * </PRE>
   *
   * @param dstBase the destination register
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSAR_RegInd_Reg_Quad(GPR dstBase, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(dstBase, GPR.getForOpcode(0x7));
    if (lister != null) lister.RNR(miStart, "SAR", dstBase, srcReg);
  }

  /**
   * Generate a register-displacement--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSAR_RegDisp_Reg_Quad(GPR dstBase, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(dstBase, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RDR(miStart, "SAR", dstBase, dstDisp, srcReg);
  }

  /**
   * Generate a register-offset--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSAR_RegOff_Reg_Quad(GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RFDR(miStart, "SAR", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate an absolute--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstDisp] by srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSAR_Abs_Reg_Quad(Address dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, null, null);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RAR(miStart, "SAR", dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register SAR. That is,
   * <PRE>
   * arithemetic shift right of [dstBase + dstIndex<<dstScale + dstDisp] by srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg must always be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSAR_RegIdx_Reg_Quad(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, GPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == ECX);
    // no size prefix
    generateREXprefix(true, null, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, GPR.getForOpcode(0x7));
    if (lister != null) lister.RXDR(miStart, "SAR", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register--register--immediate SHLD. That is,
   * <PRE>
   * left <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination register
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHLD_Reg_Reg_Imm(GPR left, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitRegRegOperands(left, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RRI(miStart, "SHLD", left, right, shiftBy);
  }

  /**
   * Generate a register-indirect--register--immediate SHLD. That is,
   * <PRE>
   * [left] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHLD_RegInd_Reg_Imm(GPR left, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitRegIndirectRegOperands(left, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RNRI(miStart, "SHLD", left, right, shiftBy);
  }

  /**
   * Generate a register-displacement--register--immediate SHLD. That is,
   * <PRE>
   * [left + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHLD_RegDisp_Reg_Imm(GPR left, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitRegDispRegOperands(left, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RDRI(miStart, "SHLD", left, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--immediate SHLD. That is,
   * <PRE>
   * [leftBase + leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftBase the destination base register
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHLD_RegIdx_Reg_Imm(GPR leftBase, GPR leftIndex, short scale, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, leftIndex, leftBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitSIBRegOperands(leftBase, leftIndex, scale, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RXDRI(miStart, "SHLD", leftBase, leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-offset--register--immediate SHLD. That is,
   * <PRE>
   * [leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHLD_RegOff_Reg_Imm(GPR leftIndex, short scale, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, leftIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitRegOffRegOperands(leftIndex, scale, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RFDRI(miStart, "SHLD", leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate an absolute--register--immediate SHLD. That is,
   * <PRE>
   * [disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHLD_Abs_Reg_Imm(Address disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitAbsRegOperands(disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RARI(miStart, "SHLD", disp, right, shiftBy);
  }

  /**
   * Generate a register--register--register SHLD. That is,
   * <PRE>
   * left <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination register
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSHLD_Reg_Reg_Reg(GPR left, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitRegRegOperands(left, right);
    if (lister != null) lister.RRR(miStart, "SHLD", left, right, shiftBy);
  }

  /**
   * Generate a register-indirect--register--register SHLD. That is,
   * <PRE>
   * [left] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSHLD_RegInd_Reg_Reg(GPR left, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitRegIndirectRegOperands(left, right);
    if (lister != null) lister.RNRR(miStart, "SHLD", left, right, shiftBy);
  }

  /**
   * Generate a register-displacement--register--register SHLD. That is,
   * <PRE>
   * [left + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3,4})
  public final void emitSHLD_RegDisp_Reg_Reg(GPR left, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitRegDispRegOperands(left, disp, right);
    if (lister != null) lister.RDRR(miStart, "SHLD", left, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHLD. That is,
   * <PRE>
   * [leftBase + leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftBase the destination base register
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5,6})
  public final void emitSHLD_RegIdx_Reg_Reg(GPR leftBase, GPR leftIndex, short scale, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, leftIndex, leftBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitSIBRegOperands(leftBase, leftIndex, scale, disp, right);
    if (lister != null) lister.RXDRR(miStart, "SHLD", leftBase, leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHLD. That is,
   * <PRE>
   * [leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4,5})
  public final void emitSHLD_RegOff_Reg_Reg(GPR leftIndex, short scale, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, leftIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitRegOffRegOperands(leftIndex, scale, disp, right);
    if (lister != null) lister.RFDRR(miStart, "SHLD", leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHLD. That is,
   * <PRE>
   * [disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  public final void emitSHLD_Abs_Reg_Reg(Address disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitAbsRegOperands(disp, right);
    if (lister != null) lister.RARR(miStart, "SHLD", disp, right, shiftBy);
  }

  /**
   * Generate a register--register--immediate SHLD. That is,
   * <PRE>
   * left <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination register
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHLD_Reg_Reg_Imm_Quad(GPR left, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitRegRegOperands(left, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RRI(miStart, "SHLD", left, right, shiftBy);
  }

  /**
   * Generate a register-indirect--register--immediate SHLD. That is,
   * <PRE>
   * [left] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHLD_RegInd_Reg_Imm_Quad(GPR left, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitRegIndirectRegOperands(left, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RNRI(miStart, "SHLD", left, right, shiftBy);
  }

  /**
   * Generate a register-displacement--register--immediate SHLD. That is,
   * <PRE>
   * [left + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHLD_RegDisp_Reg_Imm_Quad(GPR left, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitRegDispRegOperands(left, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RDRI(miStart, "SHLD", left, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--immediate SHLD. That is,
   * <PRE>
   * [leftBase + leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftBase the destination base register
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHLD_RegIdx_Reg_Imm_Quad(GPR leftBase, GPR leftIndex, short scale, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, leftIndex, leftBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitSIBRegOperands(leftBase, leftIndex, scale, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RXDRI(miStart, "SHLD", leftBase, leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-offset--register--immediate SHLD. That is,
   * <PRE>
   * [leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHLD_RegOff_Reg_Imm_Quad(GPR leftIndex, short scale, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, leftIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitRegOffRegOperands(leftIndex, scale, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RFDRI(miStart, "SHLD", leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate an absolute--register--immediate SHLD. That is,
   * <PRE>
   * [disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHLD_Abs_Reg_Imm_Quad(Address disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA4);
    emitAbsRegOperands(disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RARI(miStart, "SHLD", disp, right, shiftBy);
  }

  /**
   * Generate a register--register--register SHLD. That is,
   * <PRE>
   * left <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination register
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSHLD_Reg_Reg_Reg_Quad(GPR left, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitRegRegOperands(left, right);
    if (lister != null) lister.RRR(miStart, "SHLD", left, right, shiftBy);
  }

  /**
   * Generate a register-indirect--register--register SHLD. That is,
   * <PRE>
   * [left] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSHLD_RegInd_Reg_Reg_Quad(GPR left, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitRegIndirectRegOperands(left, right);
    if (lister != null) lister.RNRR(miStart, "SHLD", left, right, shiftBy);
  }

  /**
   * Generate a register-displacement--register--register SHLD. That is,
   * <PRE>
   * [left + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3,4})
  public final void emitSHLD_RegDisp_Reg_Reg_Quad(GPR left, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitRegDispRegOperands(left, disp, right);
    if (lister != null) lister.RDRR(miStart, "SHLD", left, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHLD. That is,
   * <PRE>
   * [leftBase + leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftBase the destination base register
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5,6})
  public final void emitSHLD_RegIdx_Reg_Reg_Quad(GPR leftBase, GPR leftIndex, short scale, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, leftIndex, leftBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitSIBRegOperands(leftBase, leftIndex, scale, disp, right);
    if (lister != null) lister.RXDRR(miStart, "SHLD", leftBase, leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHLD. That is,
   * <PRE>
   * [leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4,5})
  public final void emitSHLD_RegOff_Reg_Reg_Quad(GPR leftIndex, short scale, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, leftIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitRegOffRegOperands(leftIndex, scale, disp, right);
    if (lister != null) lister.RFDRR(miStart, "SHLD", leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHLD. That is,
   * <PRE>
   * [disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  public final void emitSHLD_Abs_Reg_Reg_Quad(Address disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xA5);
    emitAbsRegOperands(disp, right);
    if (lister != null) lister.RARR(miStart, "SHLD", disp, right, shiftBy);
  }

  /**
   * Generate a register--register--immediate SHRD. That is,
   * <PRE>
   * left <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination register
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHRD_Reg_Reg_Imm(GPR left, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitRegRegOperands(left, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RRI(miStart, "SHRD", left, right, shiftBy);
  }

  /**
   * Generate a register-indirect--register--immediate SHRD. That is,
   * <PRE>
   * [left] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHRD_RegInd_Reg_Imm(GPR left, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitRegIndirectRegOperands(left, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RNRI(miStart, "SHRD", left, right, shiftBy);
  }

  /**
   * Generate a register-displacement--register--immediate SHRD. That is,
   * <PRE>
   * [left + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHRD_RegDisp_Reg_Imm(GPR left, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitRegDispRegOperands(left, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RDRI(miStart, "SHRD", left, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--immediate SHRD. That is,
   * <PRE>
   * [leftBase + leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftBase the destination base register
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHRD_RegIdx_Reg_Imm(GPR leftBase, GPR leftIndex, short scale, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, leftIndex, leftBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitSIBRegOperands(leftBase, leftIndex, scale, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RXDRI(miStart, "SHRD", leftBase, leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-offset--register--immediate SHRD. That is,
   * <PRE>
   * [leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHRD_RegOff_Reg_Imm(GPR leftIndex, short scale, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, leftIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitRegOffRegOperands(leftIndex, scale, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RFDRI(miStart, "SHRD", leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate an absolute--register--immediate SHRD. That is,
   * <PRE>
   * [disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHRD_Abs_Reg_Imm(Address disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(false, right, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitAbsRegOperands(disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RARI(miStart, "SHRD", disp, right, shiftBy);
  }

  /**
   * Generate a register--register--register SHRD. That is,
   * <PRE>
   * left <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination register
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSHRD_Reg_Reg_Reg(GPR left, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitRegRegOperands(left, right);
    if (lister != null) lister.RRR(miStart, "SHRD", left, right, shiftBy);
  }

  /**
   * Generate a register-indirect--register--register SHRD. That is,
   * <PRE>
   * [left] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSHRD_RegInd_Reg_Reg(GPR left, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitRegIndirectRegOperands(left, right);
    if (lister != null) lister.RNRR(miStart, "SHRD", left, right, shiftBy);
  }

  /**
   * Generate a register-displacement--register--register SHRD. That is,
   * <PRE>
   * [left + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3,4})
  public final void emitSHRD_RegDisp_Reg_Reg(GPR left, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitRegDispRegOperands(left, disp, right);
    if (lister != null) lister.RDRR(miStart, "SHRD", left, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHRD. That is,
   * <PRE>
   * [leftBase + leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftBase the destination base register
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5,6})
  public final void emitSHRD_RegIdx_Reg_Reg(GPR leftBase, GPR leftIndex, short scale, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, leftIndex, leftBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitSIBRegOperands(leftBase, leftIndex, scale, disp, right);
    if (lister != null) lister.RXDRR(miStart, "SHRD", leftBase, leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHRD. That is,
   * <PRE>
   * [leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4,5})
  public final void emitSHRD_RegOff_Reg_Reg(GPR leftIndex, short scale, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, leftIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitRegOffRegOperands(leftIndex, scale, disp, right);
    if (lister != null) lister.RFDRR(miStart, "SHRD", leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHRD. That is,
   * <PRE>
   * [disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  public final void emitSHRD_Abs_Reg_Reg(Address disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(false, right, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitAbsRegOperands(disp, right);
    if (lister != null) lister.RARR(miStart, "SHRD", disp, right, shiftBy);
  }

  /**
   * Generate a register--register--immediate SHRD. That is,
   * <PRE>
   * left <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination register
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHRD_Reg_Reg_Imm_Quad(GPR left, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitRegRegOperands(left, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RRI(miStart, "SHRD", left, right, shiftBy);
  }

  /**
   * Generate a register-indirect--register--immediate SHRD. That is,
   * <PRE>
   * [left] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSHRD_RegInd_Reg_Imm_Quad(GPR left, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitRegIndirectRegOperands(left, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RNRI(miStart, "SHRD", left, right, shiftBy);
  }

  /**
   * Generate a register-displacement--register--immediate SHRD. That is,
   * <PRE>
   * [left + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitSHRD_RegDisp_Reg_Imm_Quad(GPR left, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitRegDispRegOperands(left, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RDRI(miStart, "SHRD", left, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--immediate SHRD. That is,
   * <PRE>
   * [leftBase + leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftBase the destination base register
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitSHRD_RegIdx_Reg_Imm_Quad(GPR leftBase, GPR leftIndex, short scale, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, leftIndex, leftBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitSIBRegOperands(leftBase, leftIndex, scale, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RXDRI(miStart, "SHRD", leftBase, leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-offset--register--immediate SHRD. That is,
   * <PRE>
   * [leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitSHRD_RegOff_Reg_Imm_Quad(GPR leftIndex, short scale, Offset disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, leftIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitRegOffRegOperands(leftIndex, scale, disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RFDRI(miStart, "SHRD", leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate an absolute--register--immediate SHRD. That is,
   * <PRE>
   * [disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy the amount to shift by
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitSHRD_Abs_Reg_Imm_Quad(Address disp, GPR right, int shiftBy) {
    int miStart = mi;
    generateREXprefix(true, right, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAC);
    emitAbsRegOperands(disp, right);
    emitImm8((byte)shiftBy);
    if (lister != null) lister.RARI(miStart, "SHRD", disp, right, shiftBy);
  }

  /**
   * Generate a register--register--register SHRD. That is,
   * <PRE>
   * left <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination register
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSHRD_Reg_Reg_Reg_Quad(GPR left, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitRegRegOperands(left, right);
    if (lister != null) lister.RRR(miStart, "SHRD", left, right, shiftBy);
  }

  /**
   * Generate a register-indirect--register--register SHRD. That is,
   * <PRE>
   * [left] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSHRD_RegInd_Reg_Reg_Quad(GPR left, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitRegIndirectRegOperands(left, right);
    if (lister != null) lister.RNRR(miStart, "SHRD", left, right, shiftBy);
  }

  /**
   * Generate a register-displacement--register--register SHRD. That is,
   * <PRE>
   * [left + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param left the destination base register
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3,4})
  public final void emitSHRD_RegDisp_Reg_Reg_Quad(GPR left, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, null, left);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitRegDispRegOperands(left, disp, right);
    if (lister != null) lister.RDRR(miStart, "SHRD", left, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHRD. That is,
   * <PRE>
   * [leftBase + leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftBase the destination base register
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5,6})
  public final void emitSHRD_RegIdx_Reg_Reg_Quad(GPR leftBase, GPR leftIndex, short scale, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, leftIndex, leftBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitSIBRegOperands(leftBase, leftIndex, scale, disp, right);
    if (lister != null) lister.RXDRR(miStart, "SHRD", leftBase, leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHRD. That is,
   * <PRE>
   * [leftIndex<<scale + disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param leftIndex the destination index register
   * @param scale the destination scale
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4,5})
  public final void emitSHRD_RegOff_Reg_Reg_Quad(GPR leftIndex, short scale, Offset disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, leftIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitRegOffRegOperands(leftIndex, scale, disp, right);
    if (lister != null) lister.RFDRR(miStart, "SHRD", leftIndex, scale, disp, right, shiftBy);
  }

  /**
   * Generate a register-index--register--register SHRD. That is,
   * <PRE>
   * [disp] <<= shiftBy (with bits from right shifted in)
   * </PRE>
   *
   * @param disp the destination displacement
   * @param right the register containing bits that are shifted in
   * @param shiftBy must be ECX
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2,3})
  public final void emitSHRD_Abs_Reg_Reg_Quad(Address disp, GPR right, GPR shiftBy) {
    if (VM.VerifyAssertions) VM._assert(shiftBy == ECX);
    int miStart = mi;
    generateREXprefix(true, right, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xAD);
    emitAbsRegOperands(disp, right);
    if (lister != null) lister.RARR(miStart, "SHRD", disp, right, shiftBy);
  }

  /**
   * Generate a register POP. That is,
   * <PRE>
   * pop dstReg, SP -= 4
   * </PRE>
   *
   * @param reg the destination register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPOP_Reg (GPR reg) {
    int miStart = mi;
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) (0x58 + reg.valueForOpcode()));
    if (lister != null) lister.R(miStart, "POP", reg);
  }

  /**
   * Generate a register-displacement POP. That is,
   * <PRE>
   * pop [base + disp], SP -= 4
   * </PRE>
   *
   * @param base the base register
   * @param disp the displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPOP_RegDisp (GPR base, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0x8F);
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RD(miStart, "POP", base, disp);
  }

  /**
   * Generate a register-indirect POP. That is,
   * <PRE>
   * pop [base], SP -= 4
   * </PRE>
   *
   * @param base the base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPOP_RegInd (GPR base) {
    int miStart = mi;
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0x8F);
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x0));
    if (lister != null) lister.RN(miStart, "POP", base);
  }

  /**
   * Generate a register-index POP. That is,
   * <PRE>
   * pop [base + index<<scale + disp], SP -= 4
   * </PRE>
   *
   * @param base the base register
   * @param index the index register
   * @param scale the scale
   * @param disp the displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPOP_RegIdx (GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0x8F);
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RXD(miStart, "POP", base, index, scale, disp);
  }

  /**
   * Generate a register-offset POP. That is,
   * <PRE>
   * pop [index<<scale + disp], SP -= 4
   * </PRE>
   *
   * @param index the index register
   * @param scale the scale
   * @param disp the displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPOP_RegOff (GPR index, short scale, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0x8F);
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RFD(miStart, "POP", index, scale, disp);
  }

  /**
   * Generate an absolute POP. That is,
   * <PRE>
   * pop [disp], SP -= 4
   * </PRE>
   *
   * @param disp the displacement
   */
  public final void emitPOP_Abs (Address disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x8F);
    emitAbsRegOperands(disp, GPR.getForOpcode(0x0));
    if (lister != null) lister.RA(miStart, "POP", disp);
  }

  /**
   * Generate a register PUSH. That is,
   * <PRE>
   * push dstReg, SP += 4
   * </PRE>
   *
   * @param reg the destination register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPUSH_Reg (GPR reg) {
    int miStart = mi;
    generateREXprefix(false, null, null, reg);
    setMachineCodes(mi++, (byte) (0x50 + reg.valueForOpcode()));
    if (lister != null) lister.R(miStart, "PUSH", reg);
  }

  /**
   * Generate a register-displacement PUSH. That is,
   * <PRE>
   * push [base + disp], SP += 4
   * </PRE>
   *
   * @param base the base register
   * @param disp the displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPUSH_RegDisp (GPR base, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    emitRegDispRegOperands(base, disp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RD(miStart, "PUSH", base, disp);
  }

  /**
   * Generate a register-indirect PUSH. That is,
   * <PRE>
   * push [base], SP += 4
   * </PRE>
   *
   * @param base the base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPUSH_RegInd (GPR base) {
    int miStart = mi;
    generateREXprefix(false, null, null, base);
    setMachineCodes(mi++, (byte) 0xFF);
    emitRegIndirectRegOperands(base, GPR.getForOpcode(0x6));
    if (lister != null) lister.RN(miStart, "PUSH", base);
  }

  /**
   * Generate a register-index PUSH. That is,
   * <PRE>
   * push [base + index<<scale + disp], SP += 4
   * </PRE>
   *
   * @param base the base register
   * @param index the index register
   * @param scale the scale
   * @param disp the displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPUSH_RegIdx (GPR base, GPR index, short scale, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, null, index, base);
    setMachineCodes(mi++, (byte) 0xFF);
    emitSIBRegOperands(base, index, scale, disp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RXD(miStart, "PUSH", base, index, scale, disp);
  }

  /**
   * Generate a register-offset PUSH. That is,
   * <PRE>
   * push [index<<scale + disp], SP += 4
   * </PRE>
   *
   * @param index the index register
   * @param scale the scale
   * @param disp the displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPUSH_RegOff (GPR index, short scale, Offset disp) {
    int miStart = mi;
    generateREXprefix(false, null, index, null);
    setMachineCodes(mi++, (byte) 0xFF);
    emitRegOffRegOperands(index, scale, disp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RFD(miStart, "PUSH", index, scale, disp);
  }

  /**
   * Generate an absolute PUSH. That is,
   * <PRE>
   * push [disp], SP += 4
   * </PRE>
   *
   * @param disp the displacement
   */
  public final void emitPUSH_Abs (Address disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xFF);
    emitAbsRegOperands(disp, GPR.getForOpcode(0x6));
    if (lister != null) lister.RA(miStart, "PUSH", disp);
  }

  /**
   * Generate an immediate PUSH. That is,
   * <PRE>
   * push imm, SP += 4
   * </PRE>
   *
   * @param imm the immediate value
   */
  public final void emitPUSH_Imm(int imm) {
    int miStart = mi;
    if (fits(imm, 8)) {
      setMachineCodes(mi++, (byte) 0x6A);
      emitImm8(imm);
    } else {
      setMachineCodes(mi++, (byte) 0x68);
      emitImm32(imm);
    }
    if (lister != null) lister.I(miStart, "PUSH", imm);
  }


  /**
   * Generate a register--register ADDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADDSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "ADDSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ADDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADDSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ADDSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ADDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADDSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ADDSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute ADDSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADDSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ADDSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index ADDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitADDSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ADDSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect ADDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADDSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ADDSS", dstReg, srcBase);
  }


  /**
   * Generate a register--register SUBSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUBSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "SUBSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SUBSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUBSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SUBSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SUBSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUBSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SUBSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute SUBSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUBSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SUBSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index SUBSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSUBSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SUBSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect SUBSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUBSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SUBSS", dstReg, srcBase);
  }


  /**
   * Generate a register--register MULSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMULSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MULSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MULSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMULSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MULSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MULSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMULSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MULSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute MULSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMULSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MULSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index MULSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMULSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MULSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect MULSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMULSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MULSS", dstReg, srcBase);
  }


  /**
   * Generate a register--register DIVSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIVSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "DIVSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement DIVSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIVSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "DIVSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset DIVSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIVSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "DIVSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute DIVSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDIVSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "DIVSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index DIVSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitDIVSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "DIVSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect DIVSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIVSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "DIVSS", dstReg, srcBase);
  }


  /**
   * Generate a register--register MOVSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOVSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOVSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute MOVSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index MOVSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect MOVSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVSS", dstReg, srcBase);
  }


  /**
   * Generate a register-indirect--register MOVSS. That is,
   * <PRE>
   * [dstBase] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSS_RegInd_Reg(GPR dstBase, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x11);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOVSS", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOVSS. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOVSS_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x11);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOVSS", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOVSS. That is,
   * <PRE>
   * [dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOVSS_Abs_Reg(Address dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x11);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOVSS", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOVSS. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOVSS_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x11);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOVSS", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOVSS. That is,
   * <PRE>
   * [dstBase + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOVSS_RegDisp_Reg(GPR dstBase, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x11);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOVSS", dstBase, dstDisp, srcReg);
  }


  /**
   * Generate a register--register MOVLPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVLPS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVLPS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOVLPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVLPS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVLPS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOVLPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVLPS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVLPS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute MOVLPS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVLPS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVLPS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index MOVLPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVLPS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVLPS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect MOVLPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVLPS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVLPS", dstReg, srcBase);
  }


  /**
   * Generate a register-indirect--register MOVLPS. That is,
   * <PRE>
   * [dstBase] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVLPS_RegInd_Reg(GPR dstBase, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x13);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOVLPS", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOVLPS. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOVLPS_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x13);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOVLPS", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOVLPS. That is,
   * <PRE>
   * [dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOVLPS_Abs_Reg(Address dstDisp, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x13);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOVLPS", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOVLPS. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOVLPS_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x13);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOVLPS", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOVLPS. That is,
   * <PRE>
   * [dstBase + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOVLPS_RegDisp_Reg(GPR dstBase, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x13);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOVLPS", dstBase, dstDisp, srcReg);
  }


  /**
   * Generate a register--register SQRTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSQRTSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "SQRTSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SQRTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSQRTSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SQRTSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SQRTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSQRTSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SQRTSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute SQRTSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSQRTSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SQRTSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index SQRTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSQRTSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SQRTSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect SQRTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSQRTSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SQRTSS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTSS2SD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTSS2SD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTSS2SD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTSS2SD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTSS2SD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTSS2SD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTSS2SD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTSS2SD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTSS2SD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTSS2SD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTSS2SD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTSS2SD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTSS2SD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTSS2SD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTSI2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SS_Reg_Reg(XMM dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTSI2SS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTSI2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTSI2SS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTSI2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTSI2SS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTSI2SS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTSI2SS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTSI2SS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTSI2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTSI2SS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTSI2SS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTSI2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTSI2SS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTSI2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SS_Reg_Reg_Quad(XMM dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTSI2SS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTSI2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SS_Reg_RegDisp_Quad(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTSI2SS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTSI2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SS_Reg_RegOff_Quad(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTSI2SS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTSI2SS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTSI2SS_Reg_Abs_Quad(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTSI2SS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTSI2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTSI2SS_Reg_RegIdx_Quad(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTSI2SS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTSI2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SS_Reg_RegInd_Quad(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTSI2SS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SI_Reg_Reg(GPR dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTSS2SI", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SI_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTSS2SI", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SI_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTSS2SI", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTSS2SI. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTSS2SI_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTSS2SI", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTSS2SI_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTSS2SI", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SI_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTSS2SI", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SI_Reg_Reg_Quad(GPR dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTSS2SI", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SI_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTSS2SI", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SI_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTSS2SI", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTSS2SI. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTSS2SI_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTSS2SI", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTSS2SI_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTSS2SI", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSS2SI_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTSS2SI", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSS2SI_Reg_Reg(GPR dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTTSS2SI", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSS2SI_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTTSS2SI", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSS2SI_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTTSS2SI", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTTSS2SI. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTTSS2SI_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTTSS2SI", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTTSS2SI_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTTSS2SI", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSS2SI_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTTSS2SI", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSS2SI_Reg_Reg_Quad(GPR dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTTSS2SI", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSS2SI_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTTSS2SI", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSS2SI_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTTSS2SI", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTTSS2SI. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTTSS2SI_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTTSS2SI", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTTSS2SI_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTTSS2SI", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTTSS2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSS2SI_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTTSS2SI", dstReg, srcBase);
  }


  /**
   * Generate a register--register UCOMISS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitUCOMISS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "UCOMISS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement UCOMISS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitUCOMISS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "UCOMISS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset UCOMISS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitUCOMISS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "UCOMISS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute UCOMISS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitUCOMISS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "UCOMISS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index UCOMISS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitUCOMISS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "UCOMISS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect UCOMISS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitUCOMISS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "UCOMISS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPEQSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPEQSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RR(miStart, "CMPEQSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPEQSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPEQSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RRD(miStart, "CMPEQSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPEQSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPEQSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RRFD(miStart, "CMPEQSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPEQSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPEQSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RRA(miStart, "CMPEQSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPEQSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPEQSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RRXD(miStart, "CMPEQSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPEQSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPEQSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RRN(miStart, "CMPEQSS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPLTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLTSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RR(miStart, "CMPLTSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPLTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLTSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RRD(miStart, "CMPLTSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPLTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLTSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RRFD(miStart, "CMPLTSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPLTSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPLTSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RRA(miStart, "CMPLTSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPLTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPLTSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RRXD(miStart, "CMPLTSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPLTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLTSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RRN(miStart, "CMPLTSS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPLESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLESS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RR(miStart, "CMPLESS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPLESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLESS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RRD(miStart, "CMPLESS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPLESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLESS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RRFD(miStart, "CMPLESS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPLESS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPLESS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RRA(miStart, "CMPLESS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPLESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPLESS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RRXD(miStart, "CMPLESS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPLESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLESS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RRN(miStart, "CMPLESS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPUNORDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPUNORDSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RR(miStart, "CMPUNORDSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPUNORDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPUNORDSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RRD(miStart, "CMPUNORDSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPUNORDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPUNORDSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RRFD(miStart, "CMPUNORDSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPUNORDSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPUNORDSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RRA(miStart, "CMPUNORDSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPUNORDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPUNORDSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RRXD(miStart, "CMPUNORDSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPUNORDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPUNORDSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RRN(miStart, "CMPUNORDSS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPNESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNESS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RR(miStart, "CMPNESS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPNESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNESS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RRD(miStart, "CMPNESS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPNESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNESS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RRFD(miStart, "CMPNESS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPNESS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPNESS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RRA(miStart, "CMPNESS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPNESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPNESS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RRXD(miStart, "CMPNESS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPNESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNESS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RRN(miStart, "CMPNESS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPNLTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLTSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RR(miStart, "CMPNLTSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPNLTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLTSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RRD(miStart, "CMPNLTSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPNLTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLTSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RRFD(miStart, "CMPNLTSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPNLTSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPNLTSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RRA(miStart, "CMPNLTSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPNLTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPNLTSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RRXD(miStart, "CMPNLTSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPNLTSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLTSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RRN(miStart, "CMPNLTSS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPNLESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLESS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RR(miStart, "CMPNLESS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPNLESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLESS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RRD(miStart, "CMPNLESS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPNLESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLESS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RRFD(miStart, "CMPNLESS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPNLESS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPNLESS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RRA(miStart, "CMPNLESS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPNLESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPNLESS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RRXD(miStart, "CMPNLESS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPNLESS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLESS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RRN(miStart, "CMPNLESS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPORDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPORDSS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RR(miStart, "CMPORDSS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPORDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPORDSS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RRD(miStart, "CMPORDSS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPORDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPORDSS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RRFD(miStart, "CMPORDSS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPORDSS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPORDSS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RRA(miStart, "CMPORDSS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPORDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPORDSS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RRXD(miStart, "CMPORDSS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPORDSS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPORDSS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RRN(miStart, "CMPORDSS", dstReg, srcBase);
  }


  /**
   * Generate a register--register MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_Reg_Reg(GPR dstReg, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "MOVD", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register MOVD. That is,
   * <PRE>
   * [dstBase] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_RegInd_Reg(GPR dstBase, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOVD", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOVD. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOVD_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOVD", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOVD. That is,
   * <PRE>
   * [dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOVD_Abs_Reg(Address dstDisp, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOVD", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOVD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOVD_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOVD", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOVD. That is,
   * <PRE>
   * [dstBase + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOVD_RegDisp_Reg(GPR dstBase, Offset dstDisp, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOVD", dstBase, dstDisp, srcReg);
  }


  /**
   * Generate a register--register MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_Reg_Reg(MM dstReg, GPR srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_Reg_RegDisp(MM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_Reg_RegOff(MM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute MOVD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVD_Reg_Abs(MM dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVD_Reg_RegIdx(MM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_Reg_RegInd(MM dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVD", dstReg, srcBase);
  }


  /**
   * Generate a register--register MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_Reg_Reg(GPR dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegRegOperands(dstReg, srcReg);
    if (lister != null) lister.RR(miStart, "MOVD", dstReg, srcReg);
  }

  /**
   * Generate a register-indirect--register MOVD. That is,
   * <PRE>
   * [dstBase] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_RegInd_Reg(GPR dstBase, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOVD", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOVD. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOVD_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOVD", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOVD. That is,
   * <PRE>
   * [dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOVD_Abs_Reg(Address dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOVD", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOVD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOVD_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOVD", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOVD. That is,
   * <PRE>
   * [dstBase + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOVD_RegDisp_Reg(GPR dstBase, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOVD", dstBase, dstDisp, srcReg);
  }


  /**
   * Generate a register--register MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_Reg_Reg(XMM dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute MOVD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect MOVD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6E);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVD", dstReg, srcBase);
  }


  /**
   * Generate a register--register MOVQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVQ_Reg_Reg(MM dstReg, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6F);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVQ", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOVQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVQ_Reg_RegDisp(MM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6F);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOVQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVQ_Reg_RegOff(MM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6F);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute MOVQ. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVQ_Reg_Abs(MM dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6F);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVQ", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index MOVQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVQ_Reg_RegIdx(MM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6F);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect MOVQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVQ_Reg_RegInd(MM dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x6F);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVQ", dstReg, srcBase);
  }


  /**
   * Generate a register-indirect--register MOVQ. That is,
   * <PRE>
   * [dstBase] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVQ_RegInd_Reg(GPR dstBase, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7F);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOVQ", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOVQ. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOVQ_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7F);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOVQ", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOVQ. That is,
   * <PRE>
   * [dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOVQ_Abs_Reg(Address dstDisp, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7F);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOVQ", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOVQ. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOVQ_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7F);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOVQ", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOVQ. That is,
   * <PRE>
   * [dstBase + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOVQ_RegDisp_Reg(GPR dstBase, Offset dstDisp, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7F);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOVQ", dstBase, dstDisp, srcReg);
  }


  /**
   * Generate a register--register MOVQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVQ_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVQ", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOVQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVQ_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOVQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVQ_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute MOVQ. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVQ_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVQ", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index MOVQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVQ_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect MOVQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVQ_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF3);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x7E);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVQ", dstReg, srcBase);
  }


  /**
   * Generate a register-indirect--register MOVQ. That is,
   * <PRE>
   * [dstBase] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVQ_RegInd_Reg(GPR dstBase, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD6);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOVQ", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOVQ. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOVQ_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD6);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOVQ", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOVQ. That is,
   * <PRE>
   * [dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOVQ_Abs_Reg(Address dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD6);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOVQ", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOVQ. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOVQ_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD6);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOVQ", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOVQ. That is,
   * <PRE>
   * [dstBase + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOVQ_RegDisp_Reg(GPR dstBase, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD6);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOVQ", dstBase, dstDisp, srcReg);
  }


  /**
   * Generate a register--register ADDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADDSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "ADDSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ADDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADDSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ADDSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ADDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADDSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ADDSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute ADDSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitADDSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ADDSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index ADDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitADDSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ADDSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect ADDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitADDSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x58);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ADDSD", dstReg, srcBase);
  }


  /**
   * Generate a register--register SUBSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUBSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "SUBSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SUBSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUBSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SUBSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SUBSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUBSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SUBSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute SUBSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSUBSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SUBSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index SUBSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSUBSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SUBSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect SUBSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSUBSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5C);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SUBSD", dstReg, srcBase);
  }


  /**
   * Generate a register--register MULSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMULSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MULSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MULSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMULSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MULSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MULSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMULSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MULSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute MULSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMULSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MULSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index MULSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMULSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MULSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect MULSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMULSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x59);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MULSD", dstReg, srcBase);
  }


  /**
   * Generate a register--register DIVSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIVSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "DIVSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement DIVSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIVSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "DIVSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset DIVSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIVSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "DIVSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute DIVSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitDIVSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "DIVSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index DIVSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitDIVSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "DIVSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect DIVSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitDIVSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5E);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "DIVSD", dstReg, srcBase);
  }


  /**
   * Generate a register--register MOVSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOVSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOVSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute MOVSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index MOVSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect MOVSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x10);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVSD", dstReg, srcBase);
  }


  /**
   * Generate a register-indirect--register MOVSD. That is,
   * <PRE>
   * [dstBase] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVSD_RegInd_Reg(GPR dstBase, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x11);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOVSD", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOVSD. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOVSD_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x11);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOVSD", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOVSD. That is,
   * <PRE>
   * [dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOVSD_Abs_Reg(Address dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x11);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOVSD", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOVSD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOVSD_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x11);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOVSD", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOVSD. That is,
   * <PRE>
   * [dstBase + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOVSD_RegDisp_Reg(GPR dstBase, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x11);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOVSD", dstBase, dstDisp, srcReg);
  }


  /**
   * Generate a register--register MOVLPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVLPD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "MOVLPD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement MOVLPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVLPD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "MOVLPD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset MOVLPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVLPD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "MOVLPD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute MOVLPD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitMOVLPD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "MOVLPD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index MOVLPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitMOVLPD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "MOVLPD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect MOVLPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVLPD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x12);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "MOVLPD", dstReg, srcBase);
  }


  /**
   * Generate a register-indirect--register MOVLPD. That is,
   * <PRE>
   * [dstBase] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitMOVLPD_RegInd_Reg(GPR dstBase, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x13);
    emitRegIndirectRegOperands(dstBase, srcReg);
    if (lister != null) lister.RNR(miStart, "MOVLPD", dstBase, srcReg);
  }

  /**
   * Generate a register-offset--register MOVLPD. That is,
   * <PRE>
   * [dstReg<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,4})
  public final void emitMOVLPD_RegOff_Reg(GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x13);
    emitRegOffRegOperands(dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RFDR(miStart, "MOVLPD", dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a absolute--register MOVLPD. That is,
   * <PRE>
   * [dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={2})
  public final void emitMOVLPD_Abs_Reg(Address dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x13);
    emitAbsRegOperands(dstDisp, srcReg);
    if (lister != null) lister.RAR(miStart, "MOVLPD", dstDisp, srcReg);
  }

  /**
   * Generate a register-index--register MOVLPD. That is,
   * <PRE>
   * [dstBase + dstIndex<<dstScale + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstIndex the destination index register
   * @param dstScale the destination shift amount
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,5})
  public final void emitMOVLPD_RegIdx_Reg(GPR dstBase, GPR dstIndex, short dstScale, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, dstIndex, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x13);
    emitSIBRegOperands(dstBase, dstIndex, dstScale, dstDisp, srcReg);
    if (lister != null) lister.RXDR(miStart, "MOVLPD", dstBase, dstIndex, dstScale, dstDisp, srcReg);
  }

  /**
   * Generate a register-displacement--register MOVLPD. That is,
   * <PRE>
   * [dstBase + dstDisp] <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstBase the destination base register
   * @param dstDisp the destination displacement
   * @param srcReg the source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,3})
  public final void emitMOVLPD_RegDisp_Reg(GPR dstBase, Offset dstDisp, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, srcReg, null, dstBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x13);
    emitRegDispRegOperands(dstBase, dstDisp, srcReg);
    if (lister != null) lister.RDR(miStart, "MOVLPD", dstBase, dstDisp, srcReg);
  }


  /**
   * Generate a register--register SQRTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSQRTSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "SQRTSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement SQRTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSQRTSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "SQRTSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset SQRTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSQRTSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "SQRTSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute SQRTSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitSQRTSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "SQRTSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index SQRTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitSQRTSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "SQRTSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect SQRTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitSQRTSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x51);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "SQRTSD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTSI2SD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SD_Reg_Reg(XMM dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTSI2SD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTSI2SD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTSI2SD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTSI2SD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTSI2SD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTSI2SD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTSI2SD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTSI2SD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTSI2SD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTSI2SD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTSI2SD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTSI2SD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTSI2SD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTSD2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTSD2SS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTSD2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTSD2SS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTSD2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTSD2SS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTSD2SS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTSD2SS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTSD2SS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTSD2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTSD2SS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTSD2SS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTSD2SS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x5A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTSD2SS", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTSD2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SI_Reg_Reg(GPR dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTSD2SI", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTSD2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SI_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTSD2SI", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTSD2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SI_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTSD2SI", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTSD2SI. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTSD2SI_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTSD2SI", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTSD2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTSD2SI_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTSD2SI", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTSD2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SI_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTSD2SI", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTTSD2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSD2SI_Reg_Reg(GPR dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTTSD2SI", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTTSD2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSD2SI_Reg_RegDisp(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTTSD2SI", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTTSD2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSD2SI_Reg_RegOff(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTTSD2SI", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTTSD2SI. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTTSD2SI_Reg_Abs(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTTSD2SI", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTTSD2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTTSD2SI_Reg_RegIdx(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTTSD2SI", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTTSD2SI. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSD2SI_Reg_RegInd(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTTSD2SI", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTSI2SDQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SDQ_Reg_Reg_Quad(XMM dstReg, GPR srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTSI2SDQ", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTSI2SDQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SDQ_Reg_RegDisp_Quad(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTSI2SDQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTSI2SDQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SDQ_Reg_RegOff_Quad(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTSI2SDQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTSI2SDQ. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTSI2SDQ_Reg_Abs_Quad(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTSI2SDQ", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTSI2SDQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTSI2SDQ_Reg_RegIdx_Quad(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTSI2SDQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTSI2SDQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSI2SDQ_Reg_RegInd_Quad(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2A);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTSI2SDQ", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTSD2SIQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SIQ_Reg_Reg_Quad(GPR dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTSD2SIQ", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTSD2SIQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SIQ_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTSD2SIQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTSD2SIQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SIQ_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTSD2SIQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTSD2SIQ. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTSD2SIQ_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTSD2SIQ", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTSD2SIQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTSD2SIQ_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTSD2SIQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTSD2SIQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTSD2SIQ_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2D);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTSD2SIQ", dstReg, srcBase);
  }


  /**
   * Generate a register--register CVTTSD2SIQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSD2SIQ_Reg_Reg_Quad(GPR dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "CVTTSD2SIQ", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CVTTSD2SIQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSD2SIQ_Reg_RegDisp_Quad(GPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "CVTTSD2SIQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CVTTSD2SIQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSD2SIQ_Reg_RegOff_Quad(GPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "CVTTSD2SIQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CVTTSD2SIQ. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCVTTSD2SIQ_Reg_Abs_Quad(GPR dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "CVTTSD2SIQ", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CVTTSD2SIQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCVTTSD2SIQ_Reg_RegIdx_Quad(GPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "CVTTSD2SIQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CVTTSD2SIQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCVTTSD2SIQ_Reg_RegInd_Quad(GPR dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(true, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2C);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "CVTTSD2SIQ", dstReg, srcBase);
  }


  /**
   * Generate a register--register UCOMISD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitUCOMISD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "UCOMISD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement UCOMISD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitUCOMISD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "UCOMISD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset UCOMISD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitUCOMISD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "UCOMISD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute UCOMISD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitUCOMISD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "UCOMISD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index UCOMISD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitUCOMISD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "UCOMISD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect UCOMISD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitUCOMISD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x2E);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "UCOMISD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPEQSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPEQSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RR(miStart, "CMPEQSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPEQSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPEQSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RRD(miStart, "CMPEQSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPEQSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPEQSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RRFD(miStart, "CMPEQSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPEQSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPEQSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RRA(miStart, "CMPEQSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPEQSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPEQSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RRXD(miStart, "CMPEQSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPEQSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPEQSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 0);
    if (lister != null) lister.RRN(miStart, "CMPEQSD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPLTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLTSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RR(miStart, "CMPLTSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPLTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLTSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RRD(miStart, "CMPLTSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPLTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLTSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RRFD(miStart, "CMPLTSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPLTSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPLTSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RRA(miStart, "CMPLTSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPLTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPLTSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RRXD(miStart, "CMPLTSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPLTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLTSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 1);
    if (lister != null) lister.RRN(miStart, "CMPLTSD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPLESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLESD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RR(miStart, "CMPLESD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPLESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLESD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RRD(miStart, "CMPLESD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPLESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLESD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RRFD(miStart, "CMPLESD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPLESD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPLESD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RRA(miStart, "CMPLESD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPLESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPLESD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RRXD(miStart, "CMPLESD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPLESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPLESD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 2);
    if (lister != null) lister.RRN(miStart, "CMPLESD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPUNORDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPUNORDSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RR(miStart, "CMPUNORDSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPUNORDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPUNORDSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RRD(miStart, "CMPUNORDSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPUNORDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPUNORDSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RRFD(miStart, "CMPUNORDSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPUNORDSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPUNORDSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RRA(miStart, "CMPUNORDSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPUNORDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPUNORDSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RRXD(miStart, "CMPUNORDSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPUNORDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPUNORDSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 3);
    if (lister != null) lister.RRN(miStart, "CMPUNORDSD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPNESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNESD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RR(miStart, "CMPNESD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPNESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNESD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RRD(miStart, "CMPNESD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPNESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNESD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RRFD(miStart, "CMPNESD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPNESD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPNESD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RRA(miStart, "CMPNESD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPNESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPNESD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RRXD(miStart, "CMPNESD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPNESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNESD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 4);
    if (lister != null) lister.RRN(miStart, "CMPNESD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPNLTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLTSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RR(miStart, "CMPNLTSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPNLTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLTSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RRD(miStart, "CMPNLTSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPNLTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLTSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RRFD(miStart, "CMPNLTSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPNLTSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPNLTSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RRA(miStart, "CMPNLTSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPNLTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPNLTSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RRXD(miStart, "CMPNLTSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPNLTSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLTSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 5);
    if (lister != null) lister.RRN(miStart, "CMPNLTSD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPNLESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLESD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RR(miStart, "CMPNLESD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPNLESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLESD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RRD(miStart, "CMPNLESD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPNLESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLESD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RRFD(miStart, "CMPNLESD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPNLESD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPNLESD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RRA(miStart, "CMPNLESD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPNLESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPNLESD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RRXD(miStart, "CMPNLESD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPNLESD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPNLESD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 6);
    if (lister != null) lister.RRN(miStart, "CMPNLESD", dstReg, srcBase);
  }


  /**
   * Generate a register--register CMPORDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPORDSD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegRegOperands(srcReg, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RR(miStart, "CMPORDSD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement CMPORDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPORDSD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RRD(miStart, "CMPORDSD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset CMPORDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPORDSD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RRFD(miStart, "CMPORDSD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute CMPORDSD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitCMPORDSD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitAbsRegOperands(srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RRA(miStart, "CMPORDSD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index CMPORDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitCMPORDSD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RRXD(miStart, "CMPORDSD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect CMPORDSD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitCMPORDSD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xF2);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xC2);
    emitRegIndirectRegOperands(srcBase, dstReg);
    setMachineCodes(mi++, (byte) 7);
    if (lister != null) lister.RRN(miStart, "CMPORDSD", dstReg, srcBase);
  }


  /**
   * Generate a register--register PSLLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSLLQ_Reg_Reg(MM dstReg, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "PSLLQ", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement PSLLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSLLQ_Reg_RegDisp(MM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "PSLLQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset PSLLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSLLQ_Reg_RegOff(MM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "PSLLQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute PSLLQ. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPSLLQ_Reg_Abs(MM dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "PSLLQ", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index PSLLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitPSLLQ_Reg_RegIdx(MM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "PSLLQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect PSLLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSLLQ_Reg_RegInd(MM dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "PSLLQ", dstReg, srcBase);
  }


  /**
   * Generate a register--register PSRLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSRLQ_Reg_Reg(MM dstReg, MM srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "PSRLQ", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement PSRLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSRLQ_Reg_RegDisp(MM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "PSRLQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset PSRLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSRLQ_Reg_RegOff(MM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "PSRLQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute PSRLQ. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPSRLQ_Reg_Abs(MM dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "PSRLQ", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index PSRLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitPSRLQ_Reg_RegIdx(MM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "PSRLQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect PSRLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSRLQ_Reg_RegInd(MM dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "PSRLQ", dstReg, srcBase);
  }


  /**
   * Generate a register--register PSLLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSLLQ_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "PSLLQ", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement PSLLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSLLQ_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "PSLLQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset PSLLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSLLQ_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "PSLLQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute PSLLQ. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPSLLQ_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "PSLLQ", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index PSLLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitPSLLQ_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "PSLLQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect PSLLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSLLQ_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xF3);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "PSLLQ", dstReg, srcBase);
  }


  /**
   * Generate a register--register PSRLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSRLQ_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "PSRLQ", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement PSRLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSRLQ_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "PSRLQ", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset PSRLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSRLQ_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "PSRLQ", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute PSRLQ. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitPSRLQ_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "PSRLQ", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index PSRLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitPSRLQ_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "PSRLQ", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect PSRLQ. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitPSRLQ_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0xD3);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "PSRLQ", dstReg, srcBase);
  }


  /**
   * Generate a register--register ANDPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDPS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "ANDPS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ANDPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDPS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ANDPS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ANDPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDPS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ANDPS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute ANDPS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitANDPS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ANDPS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index ANDPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitANDPS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ANDPS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect ANDPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDPS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ANDPS", dstReg, srcBase);
  }


  /**
   * Generate a register--register ANDPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDPD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "ANDPD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ANDPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDPD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ANDPD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ANDPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDPD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ANDPD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute ANDPD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitANDPD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ANDPD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index ANDPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitANDPD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ANDPD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect ANDPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDPD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x54);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ANDPD", dstReg, srcBase);
  }


  /**
   * Generate a register--register ANDNPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDNPS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "ANDNPS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ANDNPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDNPS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ANDNPS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ANDNPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDNPS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ANDNPS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute ANDNPS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitANDNPS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ANDNPS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index ANDNPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitANDNPS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ANDNPS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect ANDNPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDNPS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ANDNPS", dstReg, srcBase);
  }


  /**
   * Generate a register--register ANDNPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDNPD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "ANDNPD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ANDNPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDNPD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ANDNPD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ANDNPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDNPD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ANDNPD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute ANDNPD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitANDNPD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ANDNPD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index ANDNPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitANDNPD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ANDNPD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect ANDNPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitANDNPD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x55);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ANDNPD", dstReg, srcBase);
  }


  /**
   * Generate a register--register ORPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitORPS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "ORPS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ORPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitORPS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ORPS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ORPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitORPS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ORPS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute ORPS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitORPS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ORPS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index ORPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitORPS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ORPS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect ORPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitORPS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ORPS", dstReg, srcBase);
  }


  /**
   * Generate a register--register ORPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitORPD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "ORPD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement ORPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitORPD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "ORPD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset ORPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitORPD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "ORPD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute ORPD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitORPD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "ORPD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index ORPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitORPD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "ORPD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect ORPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitORPD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x56);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "ORPD", dstReg, srcBase);
  }


  /**
   * Generate a register--register XORPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXORPS_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "XORPS", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement XORPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXORPS_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "XORPS", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset XORPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXORPS_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "XORPS", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute XORPS. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXORPS_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "XORPS", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index XORPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitXORPS_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "XORPS", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect XORPS. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXORPS_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "XORPS", dstReg, srcBase);
  }


  /**
   * Generate a register--register XORPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXORPD_Reg_Reg(XMM dstReg, XMM srcReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcReg);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitRegRegOperands(srcReg, dstReg);
    if (lister != null) lister.RR(miStart, "XORPD", dstReg, srcReg);
  }

  /**
   * Generate a register--register-displacement XORPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXORPD_Reg_RegDisp(XMM dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitRegDispRegOperands(srcBase, srcDisp, dstReg);
    if (lister != null) lister.RRD(miStart, "XORPD", dstReg, srcBase, srcDisp);
  }

  /**
   * Generate a register--register-offset XORPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXORPD_Reg_RegOff(XMM dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRFD(miStart, "XORPD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--absolute XORPD. That is,
   * <PRE>
   *  dstReg <<=  (quad)  [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcDisp the source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitXORPD_Reg_Abs(XMM dstReg, Address srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, null);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitAbsRegOperands(srcDisp, dstReg);
    if (lister != null) lister.RRA(miStart, "XORPD", dstReg, srcDisp);
  }

  /**
   * Generate a register--register-index XORPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  srcReg
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   * @param srcIndex the source index register
   * @param srcScale the source scale
   * @param srcDisp the source displacement
   */
  // dstReg <<=  (quad)  [srcBase + srcIndex<<scale + srcDisp]
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitXORPD_Reg_RegIdx(XMM dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, srcIndex, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, dstReg);
    if (lister != null) lister.RRXD(miStart, "XORPD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Generate a register--register-indirect XORPD. That is,
   * <PRE>
   * dstReg <<=  (quad)  [srcBase]
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcBase the source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitXORPD_Reg_RegInd(XMM dstReg, GPR srcBase) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x66);
    generateREXprefix(false, dstReg, null, srcBase);
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x57);
    emitRegIndirectRegOperands(srcBase, dstReg);
    if (lister != null) lister.RRN(miStart, "XORPD", dstReg, srcBase);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFADD_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 0 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRD(miStart, "FADD", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFADD_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 0 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0));
    if (lister != null) lister.RRN(miStart, "FADD", dstReg, srcBase);
  }

  /**
   * Perform + on dstReg. That is,
   * <PRE>
   * dstReg += () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFADD_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 0 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRXD(miStart, "FADD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFADD_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 0 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRFD(miStart, "FADD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFADD_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 0 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRA(miStart, "FADD", dstReg, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += (quad) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFADD_Reg_RegDisp_Quad(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 0 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRD(miStart, "FADD", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += (quad) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFADD_Reg_RegInd_Quad(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 0 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0));
    if (lister != null) lister.RRN(miStart, "FADD", dstReg, srcBase);
  }

  /**
   * Perform + on dstReg. That is,
   * <PRE>
   * dstReg += (quad) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFADD_Reg_RegIdx_Quad(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 0 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRXD(miStart, "FADD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += (quad) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFADD_Reg_RegOff_Quad(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 0 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRFD(miStart, "FADD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += (quad) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFADD_Reg_Abs_Quad(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 0 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRA(miStart, "FADD", dstReg, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIADD_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 0 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRD(miStart, "FIADD", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIADD_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 0 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0));
    if (lister != null) lister.RRN(miStart, "FIADD", dstReg, srcBase);
  }

  /**
   * Perform + on dstReg. That is,
   * <PRE>
   * dstReg += () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFIADD_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 0 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRXD(miStart, "FIADD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIADD_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 0 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRFD(miStart, "FIADD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIADD_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 0 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRA(miStart, "FIADD", dstReg, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += (word) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIADD_Reg_RegDisp_Word(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 0 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRD(miStart, "FIADD", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += (word) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIADD_Reg_RegInd_Word(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 0 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(0));
    if (lister != null) lister.RRN(miStart, "FIADD", dstReg, srcBase);
  }

  /**
   * Perform + on dstReg. That is,
   * <PRE>
   * dstReg += (word) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFIADD_Reg_RegIdx_Word(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 0 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRXD(miStart, "FIADD", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += (word) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIADD_Reg_RegOff_Word(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 0 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRFD(miStart, "FIADD", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform + on FP0. That is,
   * <PRE>
   * dstReg += (word) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIADD_Reg_Abs_Word(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 0 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(0));
    if (lister != null) lister.RRA(miStart, "FIADD", dstReg, srcDisp);
  }

  /**
   * Perform + either to or from FP0. That is,
   * <PRE>
   * dstReg += srcReg
   * </PRE>
   *
   * @param dstReg destination register, this or srcReg must be FP0
   * @param srcReg source register, this or dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFADD_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0 || dstReg == FP0);
    if (dstReg == FP0) {
      setMachineCodes(mi++, (byte) 0xD8);
      setMachineCodes(mi++, (byte) (0xC0 | srcReg.value()));
    } else if (srcReg == FP0) {
      setMachineCodes(mi++, (byte) 0xDC);
      setMachineCodes(mi++, (byte) (0xC0 | dstReg.value()));
    }
    if (lister != null) lister.RR(miStart, "FADD", dstReg, srcReg);
  }

  /**
   * Perform + then pop stack. That is,
   * <PRE>
   * srcReg += ST(0); pop stack
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFADDP_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    setMachineCodes(mi++, (byte) (0xC0 | dstReg.value()));
    if (lister != null) lister.R(miStart, "FADDP", dstReg);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIV_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 6 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRD(miStart, "FDIV", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIV_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 6 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(6));
    if (lister != null) lister.RRN(miStart, "FDIV", dstReg, srcBase);
  }

  /**
   * Perform / on dstReg. That is,
   * <PRE>
   * dstReg /= () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFDIV_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 6 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRXD(miStart, "FDIV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIV_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 6 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRFD(miStart, "FDIV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFDIV_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 6 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRA(miStart, "FDIV", dstReg, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (quad) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIV_Reg_RegDisp_Quad(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 6 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRD(miStart, "FDIV", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (quad) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIV_Reg_RegInd_Quad(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 6 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(6));
    if (lister != null) lister.RRN(miStart, "FDIV", dstReg, srcBase);
  }

  /**
   * Perform / on dstReg. That is,
   * <PRE>
   * dstReg /= (quad) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFDIV_Reg_RegIdx_Quad(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 6 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRXD(miStart, "FDIV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (quad) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIV_Reg_RegOff_Quad(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 6 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRFD(miStart, "FDIV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (quad) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFDIV_Reg_Abs_Quad(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 6 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRA(miStart, "FDIV", dstReg, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIV_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 6 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRD(miStart, "FIDIV", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIV_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 6 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(6));
    if (lister != null) lister.RRN(miStart, "FIDIV", dstReg, srcBase);
  }

  /**
   * Perform / on dstReg. That is,
   * <PRE>
   * dstReg /= () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFIDIV_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 6 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRXD(miStart, "FIDIV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIV_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 6 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRFD(miStart, "FIDIV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIDIV_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 6 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRA(miStart, "FIDIV", dstReg, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (word) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIV_Reg_RegDisp_Word(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 6 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRD(miStart, "FIDIV", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (word) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIV_Reg_RegInd_Word(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 6 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(6));
    if (lister != null) lister.RRN(miStart, "FIDIV", dstReg, srcBase);
  }

  /**
   * Perform / on dstReg. That is,
   * <PRE>
   * dstReg /= (word) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFIDIV_Reg_RegIdx_Word(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 6 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRXD(miStart, "FIDIV", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (word) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIV_Reg_RegOff_Word(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 6 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRFD(miStart, "FIDIV", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (word) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIDIV_Reg_Abs_Word(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 6 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(6));
    if (lister != null) lister.RRA(miStart, "FIDIV", dstReg, srcDisp);
  }

  /**
   * Perform / either to or from FP0. That is,
   * <PRE>
   * dstReg /= srcReg
   * </PRE>
   *
   * @param dstReg destination register, this or srcReg must be FP0
   * @param srcReg source register, this or dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIV_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0 || dstReg == FP0);
    if (dstReg == FP0) {
      setMachineCodes(mi++, (byte) 0xD8);
      setMachineCodes(mi++, (byte) (0xF0 | srcReg.value()));
    } else if (srcReg == FP0) {
      setMachineCodes(mi++, (byte) 0xDC);
      setMachineCodes(mi++, (byte) (0xF8 | dstReg.value()));
    }
    if (lister != null) lister.RR(miStart, "FDIV", dstReg, srcReg);
  }

  /**
   * Perform / then pop stack. That is,
   * <PRE>
   * srcReg /= ST(0); pop stack
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIVP_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    setMachineCodes(mi++, (byte) (0xF8 | dstReg.value()));
    if (lister != null) lister.R(miStart, "FDIVP", dstReg);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIVR_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 7 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRD(miStart, "FDIVR", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIVR_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 7 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(7));
    if (lister != null) lister.RRN(miStart, "FDIVR", dstReg, srcBase);
  }

  /**
   * Perform / on dstReg. That is,
   * <PRE>
   * dstReg /= () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFDIVR_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 7 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRXD(miStart, "FDIVR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIVR_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 7 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRFD(miStart, "FDIVR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFDIVR_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 7 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRA(miStart, "FDIVR", dstReg, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (quad) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIVR_Reg_RegDisp_Quad(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 7 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRD(miStart, "FDIVR", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (quad) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIVR_Reg_RegInd_Quad(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 7 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(7));
    if (lister != null) lister.RRN(miStart, "FDIVR", dstReg, srcBase);
  }

  /**
   * Perform / on dstReg. That is,
   * <PRE>
   * dstReg /= (quad) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFDIVR_Reg_RegIdx_Quad(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 7 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRXD(miStart, "FDIVR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (quad) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIVR_Reg_RegOff_Quad(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 7 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRFD(miStart, "FDIVR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (quad) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFDIVR_Reg_Abs_Quad(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 7 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRA(miStart, "FDIVR", dstReg, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIVR_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 7 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRD(miStart, "FIDIVR", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIVR_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 7 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(7));
    if (lister != null) lister.RRN(miStart, "FIDIVR", dstReg, srcBase);
  }

  /**
   * Perform / on dstReg. That is,
   * <PRE>
   * dstReg /= () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFIDIVR_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 7 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRXD(miStart, "FIDIVR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIVR_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 7 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRFD(miStart, "FIDIVR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIDIVR_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 7 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRA(miStart, "FIDIVR", dstReg, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (word) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIVR_Reg_RegDisp_Word(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 7 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRD(miStart, "FIDIVR", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (word) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIVR_Reg_RegInd_Word(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 7 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(7));
    if (lister != null) lister.RRN(miStart, "FIDIVR", dstReg, srcBase);
  }

  /**
   * Perform / on dstReg. That is,
   * <PRE>
   * dstReg /= (word) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFIDIVR_Reg_RegIdx_Word(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 7 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRXD(miStart, "FIDIVR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (word) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIDIVR_Reg_RegOff_Word(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 7 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRFD(miStart, "FIDIVR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform / on FP0. That is,
   * <PRE>
   * dstReg /= (word) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIDIVR_Reg_Abs_Word(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 7 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(7));
    if (lister != null) lister.RRA(miStart, "FIDIVR", dstReg, srcDisp);
  }

  /**
   * Perform / either to or from FP0. That is,
   * <PRE>
   * dstReg /= srcReg
   * </PRE>
   *
   * @param dstReg destination register, this or srcReg must be FP0
   * @param srcReg source register, this or dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIVR_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0 || dstReg == FP0);
    if (dstReg == FP0) {
      setMachineCodes(mi++, (byte) 0xD8);
      setMachineCodes(mi++, (byte) (0xF8 | srcReg.value()));
    } else if (srcReg == FP0) {
      setMachineCodes(mi++, (byte) 0xDC);
      setMachineCodes(mi++, (byte) (0xF0 | dstReg.value()));
    }
    if (lister != null) lister.RR(miStart, "FDIVR", dstReg, srcReg);
  }

  /**
   * Perform / then pop stack. That is,
   * <PRE>
   * srcReg /= ST(0); pop stack
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFDIVRP_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    setMachineCodes(mi++, (byte) (0xF0 | dstReg.value()));
    if (lister != null) lister.R(miStart, "FDIVRP", dstReg);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFMUL_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 1 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRD(miStart, "FMUL", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFMUL_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 1 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(1));
    if (lister != null) lister.RRN(miStart, "FMUL", dstReg, srcBase);
  }

  /**
   * Perform x on dstReg. That is,
   * <PRE>
   * dstReg x= () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFMUL_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 1 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRXD(miStart, "FMUL", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFMUL_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 1 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRFD(miStart, "FMUL", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFMUL_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 1 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRA(miStart, "FMUL", dstReg, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= (quad) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFMUL_Reg_RegDisp_Quad(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 1 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRD(miStart, "FMUL", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= (quad) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFMUL_Reg_RegInd_Quad(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 1 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(1));
    if (lister != null) lister.RRN(miStart, "FMUL", dstReg, srcBase);
  }

  /**
   * Perform x on dstReg. That is,
   * <PRE>
   * dstReg x= (quad) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFMUL_Reg_RegIdx_Quad(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 1 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRXD(miStart, "FMUL", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= (quad) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFMUL_Reg_RegOff_Quad(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 1 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRFD(miStart, "FMUL", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= (quad) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFMUL_Reg_Abs_Quad(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 1 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRA(miStart, "FMUL", dstReg, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIMUL_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 1 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRD(miStart, "FIMUL", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIMUL_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 1 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(1));
    if (lister != null) lister.RRN(miStart, "FIMUL", dstReg, srcBase);
  }

  /**
   * Perform x on dstReg. That is,
   * <PRE>
   * dstReg x= () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFIMUL_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 1 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRXD(miStart, "FIMUL", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIMUL_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 1 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRFD(miStart, "FIMUL", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIMUL_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 1 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRA(miStart, "FIMUL", dstReg, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= (word) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIMUL_Reg_RegDisp_Word(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 1 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRD(miStart, "FIMUL", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= (word) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIMUL_Reg_RegInd_Word(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 1 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(1));
    if (lister != null) lister.RRN(miStart, "FIMUL", dstReg, srcBase);
  }

  /**
   * Perform x on dstReg. That is,
   * <PRE>
   * dstReg x= (word) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFIMUL_Reg_RegIdx_Word(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 1 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRXD(miStart, "FIMUL", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= (word) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIMUL_Reg_RegOff_Word(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 1 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRFD(miStart, "FIMUL", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform x on FP0. That is,
   * <PRE>
   * dstReg x= (word) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIMUL_Reg_Abs_Word(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 1 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(1));
    if (lister != null) lister.RRA(miStart, "FIMUL", dstReg, srcDisp);
  }

  /**
   * Perform x either to or from FP0. That is,
   * <PRE>
   * dstReg x= srcReg
   * </PRE>
   *
   * @param dstReg destination register, this or srcReg must be FP0
   * @param srcReg source register, this or dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFMUL_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0 || dstReg == FP0);
    if (dstReg == FP0) {
      setMachineCodes(mi++, (byte) 0xD8);
      setMachineCodes(mi++, (byte) (0xC8 | srcReg.value()));
    } else if (srcReg == FP0) {
      setMachineCodes(mi++, (byte) 0xDC);
      setMachineCodes(mi++, (byte) (0xC8 | dstReg.value()));
    }
    if (lister != null) lister.RR(miStart, "FMUL", dstReg, srcReg);
  }

  /**
   * Perform x then pop stack. That is,
   * <PRE>
   * srcReg x= ST(0); pop stack
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFMULP_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    setMachineCodes(mi++, (byte) (0xC8 | dstReg.value()));
    if (lister != null) lister.R(miStart, "FMULP", dstReg);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUB_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 4 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRD(miStart, "FSUB", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUB_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 4 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(4));
    if (lister != null) lister.RRN(miStart, "FSUB", dstReg, srcBase);
  }

  /**
   * Perform - on dstReg. That is,
   * <PRE>
   * dstReg -= () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFSUB_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 4 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRXD(miStart, "FSUB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUB_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 4 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRFD(miStart, "FSUB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSUB_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 4 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRA(miStart, "FSUB", dstReg, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (quad) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUB_Reg_RegDisp_Quad(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 4 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRD(miStart, "FSUB", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (quad) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUB_Reg_RegInd_Quad(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 4 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(4));
    if (lister != null) lister.RRN(miStart, "FSUB", dstReg, srcBase);
  }

  /**
   * Perform - on dstReg. That is,
   * <PRE>
   * dstReg -= (quad) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFSUB_Reg_RegIdx_Quad(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 4 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRXD(miStart, "FSUB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (quad) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUB_Reg_RegOff_Quad(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 4 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRFD(miStart, "FSUB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (quad) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSUB_Reg_Abs_Quad(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 4 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRA(miStart, "FSUB", dstReg, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUB_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 4 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRD(miStart, "FISUB", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUB_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 4 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(4));
    if (lister != null) lister.RRN(miStart, "FISUB", dstReg, srcBase);
  }

  /**
   * Perform - on dstReg. That is,
   * <PRE>
   * dstReg -= () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFISUB_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 4 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRXD(miStart, "FISUB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUB_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 4 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRFD(miStart, "FISUB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISUB_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 4 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRA(miStart, "FISUB", dstReg, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (word) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUB_Reg_RegDisp_Word(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 4 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRD(miStart, "FISUB", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (word) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUB_Reg_RegInd_Word(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 4 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(4));
    if (lister != null) lister.RRN(miStart, "FISUB", dstReg, srcBase);
  }

  /**
   * Perform - on dstReg. That is,
   * <PRE>
   * dstReg -= (word) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFISUB_Reg_RegIdx_Word(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 4 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRXD(miStart, "FISUB", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (word) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUB_Reg_RegOff_Word(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 4 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRFD(miStart, "FISUB", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (word) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISUB_Reg_Abs_Word(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 4 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(4));
    if (lister != null) lister.RRA(miStart, "FISUB", dstReg, srcDisp);
  }

  /**
   * Perform - either to or from FP0. That is,
   * <PRE>
   * dstReg -= srcReg
   * </PRE>
   *
   * @param dstReg destination register, this or srcReg must be FP0
   * @param srcReg source register, this or dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUB_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0 || dstReg == FP0);
    if (dstReg == FP0) {
      setMachineCodes(mi++, (byte) 0xD8);
      setMachineCodes(mi++, (byte) (0xE0 | srcReg.value()));
    } else if (srcReg == FP0) {
      setMachineCodes(mi++, (byte) 0xDC);
      setMachineCodes(mi++, (byte) (0xE8 | dstReg.value()));
    }
    if (lister != null) lister.RR(miStart, "FSUB", dstReg, srcReg);
  }

  /**
   * Perform - then pop stack. That is,
   * <PRE>
   * srcReg -= ST(0); pop stack
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUBP_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    setMachineCodes(mi++, (byte) (0xE8 | dstReg.value()));
    if (lister != null) lister.R(miStart, "FSUBP", dstReg);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUBR_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 5 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRD(miStart, "FSUBR", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUBR_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 5 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(5));
    if (lister != null) lister.RRN(miStart, "FSUBR", dstReg, srcBase);
  }

  /**
   * Perform - on dstReg. That is,
   * <PRE>
   * dstReg -= () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFSUBR_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 5 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRXD(miStart, "FSUBR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUBR_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 5 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRFD(miStart, "FSUBR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSUBR_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xD8);
    // The register'' 5 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRA(miStart, "FSUBR", dstReg, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (quad) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUBR_Reg_RegDisp_Quad(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 5 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRD(miStart, "FSUBR", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (quad) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUBR_Reg_RegInd_Quad(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 5 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(5));
    if (lister != null) lister.RRN(miStart, "FSUBR", dstReg, srcBase);
  }

  /**
   * Perform - on dstReg. That is,
   * <PRE>
   * dstReg -= (quad) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFSUBR_Reg_RegIdx_Quad(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 5 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRXD(miStart, "FSUBR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (quad) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUBR_Reg_RegOff_Quad(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 5 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRFD(miStart, "FSUBR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (quad) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSUBR_Reg_Abs_Quad(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDC);
    // The register'' 5 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRA(miStart, "FSUBR", dstReg, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUBR_Reg_RegDisp(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 5 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRD(miStart, "FISUBR", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUBR_Reg_RegInd(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 5 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(5));
    if (lister != null) lister.RRN(miStart, "FISUBR", dstReg, srcBase);
  }

  /**
   * Perform - on dstReg. That is,
   * <PRE>
   * dstReg -= () [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFISUBR_Reg_RegIdx(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 5 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRXD(miStart, "FISUBR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUBR_Reg_RegOff(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 5 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRFD(miStart, "FISUBR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= () [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISUBR_Reg_Abs(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDA);
    // The register'' 5 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRA(miStart, "FISUBR", dstReg, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (word) [srcBase + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUBR_Reg_RegDisp_Word(FPR dstReg, GPR srcBase, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 5 is really part of the opcode
    emitRegDispRegOperands(srcBase, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRD(miStart, "FISUBR", dstReg, srcBase, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (word) [srcBase]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUBR_Reg_RegInd_Word(FPR dstReg, GPR srcBase) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 5 is really part of the opcode
    emitRegIndirectRegOperands(srcBase, GPR.getForOpcode(5));
    if (lister != null) lister.RRN(miStart, "FISUBR", dstReg, srcBase);
  }

  /**
   * Perform - on dstReg. That is,
   * <PRE>
   * dstReg -= (word) [srcBase + srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcBase source base register
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2,3})
  public final void emitFISUBR_Reg_RegIdx_Word(FPR dstReg, GPR srcBase, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 5 is really part of the opcode
    emitSIBRegOperands(srcBase, srcIndex, srcScale, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRXD(miStart, "FISUBR", dstReg, srcBase, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (word) [srcIndex<<srcScale + srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcIndex source index register
   * @param srcScale source scale
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISUBR_Reg_RegOff_Word(FPR dstReg, GPR srcIndex, short srcScale, Offset srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 5 is really part of the opcode
    emitRegOffRegOperands(srcIndex, srcScale, srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRFD(miStart, "FISUBR", dstReg, srcIndex, srcScale, srcDisp);
  }

  /**
   * Perform - on FP0. That is,
   * <PRE>
   * dstReg -= (word) [srcDisp]
   * </PRE>
   *
   * @param dstReg destination register, must be FP0
   * @param srcDisp source displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISUBR_Reg_Abs_Word(FPR dstReg, Address srcDisp) {
    int miStart = mi;
    // Must store result to top of stack
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    // The register'' 5 is really part of the opcode
    emitAbsRegOperands(srcDisp, GPR.getForOpcode(5));
    if (lister != null) lister.RRA(miStart, "FISUBR", dstReg, srcDisp);
  }

  /**
   * Perform - either to or from FP0. That is,
   * <PRE>
   * dstReg -= srcReg
   * </PRE>
   *
   * @param dstReg destination register, this or srcReg must be FP0
   * @param srcReg source register, this or dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUBR_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0 || dstReg == FP0);
    if (dstReg == FP0) {
      setMachineCodes(mi++, (byte) 0xD8);
      setMachineCodes(mi++, (byte) (0xE8 | srcReg.value()));
    } else if (srcReg == FP0) {
      setMachineCodes(mi++, (byte) 0xDC);
      setMachineCodes(mi++, (byte) (0xE0 | dstReg.value()));
    }
    if (lister != null) lister.RR(miStart, "FSUBR", dstReg, srcReg);
  }

  /**
   * Perform - then pop stack. That is,
   * <PRE>
   * srcReg -= ST(0); pop stack
   * </PRE>
   *
   * @param dstReg destination register
   * @param srcReg source register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSUBRP_Reg_Reg(FPR dstReg, FPR srcReg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(srcReg == FP0);
    setMachineCodes(mi++, (byte) 0xDE);
    setMachineCodes(mi++, (byte) (0xE0 | dstReg.value()));
    if (lister != null) lister.R(miStart, "FSUBRP", dstReg);
  }

  /** top of stack loaded from (double word) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLD_Reg_RegDisp(FPR dummy, GPR reg, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RD(miStart, "FLD", reg, disp);
  }

  /** top of stack loaded from (double word) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLD_Reg_RegInd(FPR dummy, GPR reg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(0));
    if (lister != null) lister.RN(miStart, "FLD", reg);
  }

  /** top of stack loaded from (double word) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFLD_Reg_RegIdx(FPR dummy, GPR baseReg, GPR idxReg, short scale, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RXD(miStart, "FLD", baseReg, idxReg, scale, disp);
  }

  /** top of stack loaded from (double word) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLD_Reg_RegOff(FPR dummy, GPR idxReg, short scale, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RFD(miStart, "FLD", idxReg, scale, disp);
  }

  /** top of stack loaded from (double word) [disp] */
  public final void emitFLD_Reg_Abs(FPR dummy, Address disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitAbsRegOperands(disp, GPR.getForOpcode(0));
    if (lister != null) lister.RA(miStart, "FLD", disp);
  }

  /** top of stack loaded from (quad) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLD_Reg_RegDisp_Quad(FPR dummy, GPR reg, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RD(miStart, "FLD", reg, disp);
  }

  /** top of stack loaded from (quad) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLD_Reg_RegInd_Quad(FPR dummy, GPR reg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(0));
    if (lister != null) lister.RN(miStart, "FLD", reg);
  }

  /** top of stack loaded from (quad) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFLD_Reg_RegIdx_Quad(FPR dummy, GPR baseReg, GPR idxReg, short scale, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RXD(miStart, "FLD", baseReg, idxReg, scale, disp);
  }

  /** top of stack loaded from (quad) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLD_Reg_RegOff_Quad(FPR dummy, GPR idxReg, short scale, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RFD(miStart, "FLD", idxReg, scale, disp);
  }

  /** top of stack loaded from (quad) [disp] */
  public final void emitFLD_Reg_Abs_Quad(FPR dummy, Address disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitAbsRegOperands(disp, GPR.getForOpcode(0));
    if (lister != null) lister.RA(miStart, "FLD", disp);
  }

  /** top of stack loaded from (word) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFILD_Reg_RegDisp_Word(FPR dummy, GPR reg, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RD(miStart, "FILD", reg, disp);
  }

  /** top of stack loaded from (word) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFILD_Reg_RegInd_Word(FPR dummy, GPR reg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(0));
    if (lister != null) lister.RN(miStart, "FILD", reg);
  }

  /** top of stack loaded from (word) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFILD_Reg_RegIdx_Word(FPR dummy, GPR baseReg, GPR idxReg, short scale, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RXD(miStart, "FILD", baseReg, idxReg, scale, disp);
  }

  /** top of stack loaded from (word) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFILD_Reg_RegOff_Word(FPR dummy, GPR idxReg, short scale, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RFD(miStart, "FILD", idxReg, scale, disp);
  }

  /** top of stack loaded from (word) [disp] */
  public final void emitFILD_Reg_Abs_Word(FPR dummy, Address disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitAbsRegOperands(disp, GPR.getForOpcode(0));
    if (lister != null) lister.RA(miStart, "FILD", disp);
  }

  /** top of stack loaded from (double word) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFILD_Reg_RegDisp(FPR dummy, GPR reg, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RD(miStart, "FILD", reg, disp);
  }

  /** top of stack loaded from (double word) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFILD_Reg_RegInd(FPR dummy, GPR reg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(0));
    if (lister != null) lister.RN(miStart, "FILD", reg);
  }

  /** top of stack loaded from (double word) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFILD_Reg_RegIdx(FPR dummy, GPR baseReg, GPR idxReg, short scale, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RXD(miStart, "FILD", baseReg, idxReg, scale, disp);
  }

  /** top of stack loaded from (double word) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFILD_Reg_RegOff(FPR dummy, GPR idxReg, short scale, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(0));
    if (lister != null) lister.RFD(miStart, "FILD", idxReg, scale, disp);
  }

  /** top of stack loaded from (double word) [disp] */
  public final void emitFILD_Reg_Abs(FPR dummy, Address disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitAbsRegOperands(disp, GPR.getForOpcode(0));
    if (lister != null) lister.RA(miStart, "FILD", disp);
  }

  /** top of stack loaded from (quad) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFILD_Reg_RegDisp_Quad(FPR dummy, GPR reg, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(5));
    if (lister != null) lister.RD(miStart, "FILD", reg, disp);
  }

  /** top of stack loaded from (quad) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFILD_Reg_RegInd_Quad(FPR dummy, GPR reg) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(5));
    if (lister != null) lister.RN(miStart, "FILD", reg);
  }

  /** top of stack loaded from (quad) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFILD_Reg_RegIdx_Quad(FPR dummy, GPR baseReg, GPR idxReg, short scale, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(5));
    if (lister != null) lister.RXD(miStart, "FILD", baseReg, idxReg, scale, disp);
  }

  /** top of stack loaded from (quad) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFILD_Reg_RegOff_Quad(FPR dummy, GPR idxReg, short scale, Offset disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(5));
    if (lister != null) lister.RFD(miStart, "FILD", idxReg, scale, disp);
  }

  /** top of stack loaded from (quad) [disp] */
  public final void emitFILD_Reg_Abs_Quad(FPR dummy, Address disp) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitAbsRegOperands(disp, GPR.getForOpcode(5));
    if (lister != null) lister.RA(miStart, "FILD", disp);
  }

  /** top of stack stored to (word) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIST_RegDisp_Reg_Word(GPR reg, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RD(miStart, "FIST", reg, disp);
  }

  /** top of stack stored to (word) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIST_RegInd_Reg_Word(GPR reg, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(2));
    if (lister != null) lister.RN(miStart, "FIST", reg);
  }

  /** top of stack stored to (word) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIST_RegIdx_Reg_Word(GPR baseReg, GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RXD(miStart, "FIST", baseReg, idxReg, scale, disp);
  }

  /** top of stack stored to (word) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIST_RegOff_Reg_Word(GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RFD(miStart, "FIST", idxReg, scale, disp);
  }

  /** top of stack stored to (word) [disp] */
  public final void emitFIST_Abs_Reg_Word(Address disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitAbsRegOperands(disp, GPR.getForOpcode(2));
    if (lister != null) lister.RA(miStart, "FIST", disp);
  }

  /** top of stack stored to (double word) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIST_RegDisp_Reg(GPR reg, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RD(miStart, "FIST", reg, disp);
  }

  /** top of stack stored to (double word) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIST_RegInd_Reg(GPR reg, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(2));
    if (lister != null) lister.RN(miStart, "FIST", reg);
  }

  /** top of stack stored to (double word) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFIST_RegIdx_Reg(GPR baseReg, GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RXD(miStart, "FIST", baseReg, idxReg, scale, disp);
  }

  /** top of stack stored to (double word) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFIST_RegOff_Reg(GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RFD(miStart, "FIST", idxReg, scale, disp);
  }

  /** top of stack stored to (double word) [disp] */
  public final void emitFIST_Abs_Reg(Address disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitAbsRegOperands(disp, GPR.getForOpcode(2));
    if (lister != null) lister.RA(miStart, "FIST", disp);
  }

  /** top of stack stored to (word) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISTP_RegDisp_Reg_Word(GPR reg, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RD(miStart, "FISTP", reg, disp);
  }

  /** top of stack stored to (word) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISTP_RegInd_Reg_Word(GPR reg, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(3));
    if (lister != null) lister.RN(miStart, "FISTP", reg);
  }

  /** top of stack stored to (word) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISTP_RegIdx_Reg_Word(GPR baseReg, GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RXD(miStart, "FISTP", baseReg, idxReg, scale, disp);
  }

  /** top of stack stored to (word) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISTP_RegOff_Reg_Word(GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RFD(miStart, "FISTP", idxReg, scale, disp);
  }

  /** top of stack stored to (word) [disp] */
  public final void emitFISTP_Abs_Reg_Word(Address disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitAbsRegOperands(disp, GPR.getForOpcode(3));
    if (lister != null) lister.RA(miStart, "FISTP", disp);
  }

  /** top of stack stored to (double word) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISTP_RegDisp_Reg(GPR reg, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RD(miStart, "FISTP", reg, disp);
  }

  /** top of stack stored to (double word) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISTP_RegInd_Reg(GPR reg, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(3));
    if (lister != null) lister.RN(miStart, "FISTP", reg);
  }

  /** top of stack stored to (double word) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISTP_RegIdx_Reg(GPR baseReg, GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RXD(miStart, "FISTP", baseReg, idxReg, scale, disp);
  }

  /** top of stack stored to (double word) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISTP_RegOff_Reg(GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RFD(miStart, "FISTP", idxReg, scale, disp);
  }

  /** top of stack stored to (double word) [disp] */
  public final void emitFISTP_Abs_Reg(Address disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    emitAbsRegOperands(disp, GPR.getForOpcode(3));
    if (lister != null) lister.RA(miStart, "FISTP", disp);
  }

  /** top of stack stored to (quad) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISTP_RegDisp_Reg_Quad(GPR reg, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(7));
    if (lister != null) lister.RD(miStart, "FISTP", reg, disp);
  }

  /** top of stack stored to (quad) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISTP_RegInd_Reg_Quad(GPR reg, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(7));
    if (lister != null) lister.RN(miStart, "FISTP", reg);
  }

  /** top of stack stored to (quad) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFISTP_RegIdx_Reg_Quad(GPR baseReg, GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(7));
    if (lister != null) lister.RXD(miStart, "FISTP", baseReg, idxReg, scale, disp);
  }

  /** top of stack stored to (quad) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFISTP_RegOff_Reg_Quad(GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(7));
    if (lister != null) lister.RFD(miStart, "FISTP", idxReg, scale, disp);
  }

  /** top of stack stored to (quad) [disp] */
  public final void emitFISTP_Abs_Reg_Quad(Address disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    emitAbsRegOperands(disp, GPR.getForOpcode(7));
    if (lister != null) lister.RA(miStart, "FISTP", disp);
  }

  /** top of stack stored to (double word) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFST_RegDisp_Reg(GPR reg, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RD(miStart, "FST", reg, disp);
  }

  /** top of stack stored to (double word) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFST_RegInd_Reg(GPR reg, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(2));
    if (lister != null) lister.RN(miStart, "FST", reg);
  }

  /** top of stack stored to (double word) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFST_RegIdx_Reg(GPR baseReg, GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RXD(miStart, "FST", baseReg, idxReg, scale, disp);
  }

  /** top of stack stored to (double word) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFST_RegOff_Reg(GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RFD(miStart, "FST", idxReg, scale, disp);
  }

  /** top of stack stored to (double word) [disp] */
  public final void emitFST_Abs_Reg(Address disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitAbsRegOperands(disp, GPR.getForOpcode(2));
    if (lister != null) lister.RA(miStart, "FST", disp);
  }

  /** top of stack stored to (quad) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFST_RegDisp_Reg_Quad(GPR reg, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RD(miStart, "FST", reg, disp);
  }

  /** top of stack stored to (quad) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFST_RegInd_Reg_Quad(GPR reg, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(2));
    if (lister != null) lister.RN(miStart, "FST", reg);
  }

  /** top of stack stored to (quad) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFST_RegIdx_Reg_Quad(GPR baseReg, GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RXD(miStart, "FST", baseReg, idxReg, scale, disp);
  }

  /** top of stack stored to (quad) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFST_RegOff_Reg_Quad(GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(2));
    if (lister != null) lister.RFD(miStart, "FST", idxReg, scale, disp);
  }

  /** top of stack stored to (quad) [disp] */
  public final void emitFST_Abs_Reg_Quad(Address disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitAbsRegOperands(disp, GPR.getForOpcode(2));
    if (lister != null) lister.RA(miStart, "FST", disp);
  }

  /** top of stack stored to (double word) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSTP_RegDisp_Reg(GPR reg, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RD(miStart, "FSTP", reg, disp);
  }

  /** top of stack stored to (double word) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSTP_RegInd_Reg(GPR reg, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(3));
    if (lister != null) lister.RN(miStart, "FSTP", reg);
  }

  /** top of stack stored to (double word) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSTP_RegIdx_Reg(GPR baseReg, GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RXD(miStart, "FSTP", baseReg, idxReg, scale, disp);
  }

  /** top of stack stored to (double word) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSTP_RegOff_Reg(GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RFD(miStart, "FSTP", idxReg, scale, disp);
  }

  /** top of stack stored to (double word) [disp] */
  public final void emitFSTP_Abs_Reg(Address disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xD9);
    emitAbsRegOperands(disp, GPR.getForOpcode(3));
    if (lister != null) lister.RA(miStart, "FSTP", disp);
  }

  /** top of stack stored to (quad) [reg + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSTP_RegDisp_Reg_Quad(GPR reg, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegDispRegOperands(reg, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RD(miStart, "FSTP", reg, disp);
  }

  /** top of stack stored to (quad) [reg] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSTP_RegInd_Reg_Quad(GPR reg, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegIndirectRegOperands(reg, GPR.getForOpcode(3));
    if (lister != null) lister.RN(miStart, "FSTP", reg);
  }

  /** top of stack stored to (quad) [baseReg + idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSTP_RegIdx_Reg_Quad(GPR baseReg, GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitSIBRegOperands(baseReg, idxReg, scale, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RXD(miStart, "FSTP", baseReg, idxReg, scale, disp);
  }

  /** top of stack stored to (quad) [idxReg<<scale + disp] */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSTP_RegOff_Reg_Quad(GPR idxReg, short scale, Offset disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegOffRegOperands(idxReg, scale, disp, GPR.getForOpcode(3));
    if (lister != null) lister.RFD(miStart, "FSTP", idxReg, scale, disp);
  }

  /** top of stack stored to (quad) [disp] */
  public final void emitFSTP_Abs_Reg_Quad(Address disp, FPR dummy) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(dummy == FP0);
    setMachineCodes(mi++, (byte) 0xDD);
    emitAbsRegOperands(disp, GPR.getForOpcode(3));
    if (lister != null) lister.RA(miStart, "FSTP", disp);
  }

  /**
   * FCOMI floating point comparison
   *
   * @param reg1 register for comparison
   * @param reg2 register for comparison
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFCOMI_Reg_Reg (FPR reg1, FPR reg2) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(reg1 == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    setMachineCodes(mi++, (byte)  (0xF0 | reg2.value()));
    if (lister != null) lister.RR(miStart, "FCOMI", reg1, reg2);
  }

  /**
   * FCOMIP floating point comparison
   *
   * @param reg1 register for comparison
   * @param reg2 register for comparison
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFCOMIP_Reg_Reg (FPR reg1, FPR reg2) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(reg1 == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    setMachineCodes(mi++, (byte)  (0xF0 | reg2.value()));
    if (lister != null) lister.RR(miStart, "FCOMIP", reg1, reg2);
  }

  /**
   * FUCOMI floating point comparison
   *
   * @param reg1 register for comparison
   * @param reg2 register for comparison
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFUCOMI_Reg_Reg (FPR reg1, FPR reg2) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(reg1 == FP0);
    setMachineCodes(mi++, (byte) 0xDB);
    setMachineCodes(mi++, (byte)  (0xE8 | reg2.value()));
    if (lister != null) lister.RR(miStart, "FUCOMI", reg1, reg2);
  }

  /**
   * FUCOMIP floating point comparison
   *
   * @param reg1 register for comparison
   * @param reg2 register for comparison
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFUCOMIP_Reg_Reg (FPR reg1, FPR reg2) {
    int miStart = mi;
    if (VM.VerifyAssertions) VM._assert(reg1 == FP0);
    setMachineCodes(mi++, (byte) 0xDF);
    setMachineCodes(mi++, (byte)  (0xE8 | reg2.value()));
    if (lister != null) lister.RR(miStart, "FUCOMIP", reg1, reg2);
  }

  /**
   * save FPU state ignoring pending exceptions - register displacement
   *
   * @param baseReg destination base register
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFNSAVE_RegDisp (GPR baseReg, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegDispRegOperands(baseReg, disp, GPR.getForOpcode(6));
    if (lister != null) lister.RD(miStart, "FNSAVE", baseReg, disp);
  }

  /**
   * save FPU state ignoring pending exceptions - register indirect
   *
   * @param baseReg destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFNSAVE_RegInd (GPR baseReg) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegIndirectRegOperands(baseReg, GPR.getForOpcode(6));
    if (lister != null) lister.RN(miStart, "FNSAVE", baseReg);
  }

  /**
   * save FPU state ignoring pending exceptions - register index
   *
   * @param baseReg destination base register
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFNSAVE_RegIdx (GPR baseReg, GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xDD);
    emitSIBRegOperands(baseReg, indexReg, scale, disp, GPR.getForOpcode(6));
    if (lister != null) lister.RXD(miStart, "FNSAVE", baseReg, indexReg, scale, disp);
  }

  /**
   * save FPU state ignoring pending exceptions - register offset
   *
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFNSAVE_RegOff (GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegOffRegOperands(indexReg, scale, disp, GPR.getForOpcode(6));
    if (lister != null) lister.RFD(miStart, "FNSAVE", indexReg, scale, disp);
  }

  /**
   * save FPU state ignoring pending exceptions - absolute address
   *
   * @param disp address to store to
   */
  public final void emitFNSAVE_Abs (Address disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xDD);
    emitAbsRegOperands(disp, GPR.getForOpcode(6));
    if (lister != null) lister.RA(miStart, "FNSAVE", disp);
  }

  /**
   * save FPU state respecting pending exceptions - register displacement
   *
   * @param baseReg destination base register
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSAVE_RegDisp (GPR baseReg, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegDispRegOperands(baseReg, disp, GPR.getForOpcode(6));
    if (lister != null) lister.RD(miStart, "FSAVE", baseReg, disp);
  }

  /**
   * save FPU state respecting pending exceptions - register indirect
   *
   * @param baseReg destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSAVE_RegInd (GPR baseReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegIndirectRegOperands(baseReg, GPR.getForOpcode(6));
    if (lister != null) lister.RN(miStart, "FSAVE", baseReg);
  }

  /**
   * save FPU state respecting pending exceptions - register index
   *
   * @param baseReg destination base register
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSAVE_RegIdx (GPR baseReg, GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xDD);
    emitSIBRegOperands(baseReg, indexReg, scale, disp, GPR.getForOpcode(6));
    if (lister != null) lister.RXD(miStart, "FSAVE", baseReg, indexReg, scale, disp);
  }

  /**
   * save FPU state respecting pending exceptions - register offset
   *
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSAVE_RegOff (GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegOffRegOperands(indexReg, scale, disp, GPR.getForOpcode(6));
    if (lister != null) lister.RFD(miStart, "FSAVE", indexReg, scale, disp);
  }

  /**
   * save FPU state respecting pending exceptions - absolute address
   *
   * @param disp address to store to
   */
  public final void emitFSAVE_Abs (Address disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xDD);
    emitAbsRegOperands(disp, GPR.getForOpcode(6));
    if (lister != null) lister.RA(miStart, "FSAVE", disp);
  }

  /**
   * restore FPU state - register displacement
   *
   * @param baseReg destination base register
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFRSTOR_RegDisp (GPR baseReg, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegDispRegOperands(baseReg, disp, GPR.getForOpcode(4));
    if (lister != null) lister.RD(miStart, "FRSTOR", baseReg, disp);
  }

  /**
   * restore FPU state - register indirect
   *
   * @param baseReg destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFRSTOR_RegInd (GPR baseReg) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegIndirectRegOperands(baseReg, GPR.getForOpcode(4));
    if (lister != null) lister.RN(miStart, "FRSTOR", baseReg);
  }

  /**
   * restore FPU state - register index
   *
   * @param baseReg destination base register
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFRSTOR_RegIdx (GPR baseReg, GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xDD);
    emitSIBRegOperands(baseReg, indexReg, scale, disp, GPR.getForOpcode(4));
    if (lister != null) lister.RXD(miStart, "FRSTOR", baseReg, indexReg, scale, disp);
  }

  /**
   * restore FPU state - register offset
   *
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFRSTOR_RegOff (GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xDD);
    emitRegOffRegOperands(indexReg, scale, disp, GPR.getForOpcode(4));
    if (lister != null) lister.RFD(miStart, "FRSTOR", indexReg, scale, disp);
  }

  /**
   * restore FPU state - absolute address
   *
   * @param disp address to store to
   */
  public final void emitFRSTOR_Abs (Address disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xDD);
    emitAbsRegOperands(disp, GPR.getForOpcode(4));
    if (lister != null) lister.RA(miStart, "FRSTOR", disp);
  }

  /**
   * load FPU control word - register displacement
   *
   * @param baseReg destination base register
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLDCW_RegDisp (GPR baseReg, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegDispRegOperands(baseReg, disp, GPR.getForOpcode(5));
    if (lister != null) lister.RD(miStart, "FLDCW", baseReg, disp);
  }

  /**
   * load FPU control word - register indirect
   *
   * @param baseReg destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLDCW_RegInd (GPR baseReg) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegIndirectRegOperands(baseReg, GPR.getForOpcode(5));
    if (lister != null) lister.RN(miStart, "FLDCW", baseReg);
  }

  /**
   * load FPU control word - register index
   *
   * @param baseReg destination base register
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFLDCW_RegIdx (GPR baseReg, GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xD9);
    emitSIBRegOperands(baseReg, indexReg, scale, disp, GPR.getForOpcode(5));
    if (lister != null) lister.RXD(miStart, "FLDCW", baseReg, indexReg, scale, disp);
  }

  /**
   * load FPU control word - register offset
   *
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLDCW_RegOff (GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegOffRegOperands(indexReg, scale, disp, GPR.getForOpcode(5));
    if (lister != null) lister.RFD(miStart, "FLDCW", indexReg, scale, disp);
  }

  /**
   * load FPU control word - absolute address
   *
   * @param disp address to store to
   */
  public final void emitFLDCW_Abs (Address disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xD9);
    emitAbsRegOperands(disp, GPR.getForOpcode(5));
    if (lister != null) lister.RA(miStart, "FLDCW", disp);
  }

  /**
   * store FPU control word, checking for exceptions - register displacement
   *
   * @param baseReg destination base register
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSTCW_RegDisp (GPR baseReg, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegDispRegOperands(baseReg, disp, GPR.getForOpcode(7));
    if (lister != null) lister.RD(miStart, "FSTCW", baseReg, disp);
  }

  /**
   * store FPU control word, checking for exceptions - register indirect
   *
   * @param baseReg destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSTCW_RegInd (GPR baseReg) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegIndirectRegOperands(baseReg, GPR.getForOpcode(7));
    if (lister != null) lister.RN(miStart, "FSTCW", baseReg);
  }

  /**
   * store FPU control word, checking for exceptions - register index
   *
   * @param baseReg destination base register
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFSTCW_RegIdx (GPR baseReg, GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xD9);
    emitSIBRegOperands(baseReg, indexReg, scale, disp, GPR.getForOpcode(7));
    if (lister != null) lister.RXD(miStart, "FSTCW", baseReg, indexReg, scale, disp);
  }

  /**
   * store FPU control word, checking for exceptions - register offset
   *
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFSTCW_RegOff (GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegOffRegOperands(indexReg, scale, disp, GPR.getForOpcode(7));
    if (lister != null) lister.RFD(miStart, "FSTCW", indexReg, scale, disp);
  }

  /**
   * store FPU control word, checking for exceptions - absolute address
   *
   * @param disp address to store to
   */
  public final void emitFSTCW_Abs (Address disp) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x9B);
    setMachineCodes(mi++, (byte) 0xD9);
    emitAbsRegOperands(disp, GPR.getForOpcode(7));
    if (lister != null) lister.RA(miStart, "FSTCW", disp);
  }

  /**
   * store FPU control word, ignoring exceptions - register displacement
   *
   * @param baseReg destination base register
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFNSTCW_RegDisp (GPR baseReg, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegDispRegOperands(baseReg, disp, GPR.getForOpcode(7));
    if (lister != null) lister.RD(miStart, "FNSTCW", baseReg, disp);
  }

  /**
   * store FPU control word, ignoring exceptions - register indirect
   *
   * @param baseReg destination base register
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFNSTCW_RegInd (GPR baseReg) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegIndirectRegOperands(baseReg, GPR.getForOpcode(7));
    if (lister != null) lister.RN(miStart, "FNSTCW", baseReg);
  }

  /**
   * store FPU control word, ignoring exceptions - register index
   *
   * @param baseReg destination base register
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1,2})
  public final void emitFNSTCW_RegIdx (GPR baseReg, GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xD9);
    emitSIBRegOperands(baseReg, indexReg, scale, disp, GPR.getForOpcode(7));
    if (lister != null) lister.RXD(miStart, "FNSTCW", baseReg, indexReg, scale, disp);
  }

  /**
   * store FPU control word, ignoring exceptions - register offset
   *
   * @param indexReg destination index register
   * @param scale destination scale
   * @param disp destination displacement
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFNSTCW_RegOff (GPR indexReg, short scale, Offset disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xD9);
    emitRegOffRegOperands(indexReg, scale, disp, GPR.getForOpcode(7));
    if (lister != null) lister.RFD(miStart, "FNSTCW", indexReg, scale, disp);
  }

  /**
   * store FPU control word, ignoring exceptions - absolute address
   *
   * @param disp address to store to
   */
  public final void emitFNSTCW_Abs (Address disp) {
    int miStart = mi;
    // no prefix byte
    setMachineCodes(mi++, (byte) 0xD9);
    emitAbsRegOperands(disp, GPR.getForOpcode(7));
    if (lister != null) lister.RA(miStart, "FNSTCW", disp);
  }

  /**
   * load 1.0 into FP0
   *
   * @param dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLD1_Reg(FPR dstReg) {
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xE8);
    if (lister != null) lister.R(miStart, "FLD1", dstReg);
  }

  /**
   * load log_2(10) into FP0
   *
   * @param dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLDL2T_Reg(FPR dstReg) {
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xE9);
    if (lister != null) lister.R(miStart, "FLDL2T", dstReg);
  }

  /**
   * load log_2(e) into FP0
   *
   * @param dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLDL2E_Reg(FPR dstReg) {
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xEA);
    if (lister != null) lister.R(miStart, "FLDL2E", dstReg);
  }

  /**
   * load pi into FP0
   *
   * @param dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLDPI_Reg(FPR dstReg) {
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xEB);
    if (lister != null) lister.R(miStart, "FLDPI", dstReg);
  }

  /**
   * load log_10(2) into FP0
   *
   * @param dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLDLG2_Reg(FPR dstReg) {
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xEC);
    if (lister != null) lister.R(miStart, "FLDLG2", dstReg);
  }

  /**
   * load log_e(2) into FP0
   *
   * @param dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLDLN2_Reg(FPR dstReg) {
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xED);
    if (lister != null) lister.R(miStart, "FLDLN2", dstReg);
  }

  /**
   * load 0.0 into FP0
   *
   * @param dstReg must be FP0
   */
  @Inline(value=Inline.When.ArgumentsAreConstant, arguments={1})
  public final void emitFLDZ_Reg(FPR dstReg) {
    if (VM.VerifyAssertions) VM._assert(dstReg == FP0);
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xEE);
    if (lister != null) lister.R(miStart, "FLDZ", dstReg);
  }

}
